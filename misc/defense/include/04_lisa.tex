\section{Sprachspezifikation}
\begin{frame}[t]{Sprachspezifikation}
	\note{Ruben\\}
	\note{Dauer 8min\\}
	\note[item]{Syntax}
	\note[item]{Spezielle Sprachkonstrukte}
	\note[item]{SubtypeOf}
	\note[item]{SubclassOf}
	\note[item]{MyType}
	\note[item]{Recursion}
	\note[item]{Parametrisation}
	\note[item]{Translation}
	\note[item]{Inference Rules}

	\begin{bigitemize}{3mm}
		\item Syntax
		\item Spezielle Sprachkonstrukte
		\item Rekursion
		\item Typen-Parametrisierung
		\item Übersetzung
		\item Inferenzregeln
	\end{bigitemize}
\end{frame}

\subsection{Syntax}
\begin{frame}[fragile]{Syntax}
\begin{lstlisting}[language=ooplss]
class Animal {
  def mate(other: MyType): MyType { %\ldots) }
}

class Dog subclassOf Animal {
  def mate(other: MyType): MyType { %\ldots) }
}

class Cat subclassOf Animal {
  def mate(other: MyType): MyType { %\ldots) }
}

class Persian subtypeOf Cat {
  var needsGrooming: Bool;
  def mate(other: MyType): MyType { %\ldots) }
}
\end{lstlisting}
\end{frame}

\subsection{Spezielle Sprachkonstrukte}
\begin{frame}{Spezielle Sprachkonstrukte}
	\begin{bigdescription}[<+->]{3mm}
		\item[SubtypeOf] Erstellt einen expliziten Subtyp
		\note[item]<1>{Subtypeof => extends in Java}

		\item[SubclassOf] Erstellt eine explizite Subklasse
		\note[item]<2>{SubclassOf}

		\item[MyType] Impliziter Typparameter
		\note[item]<3>{MyType}
		\note[item]<3>{Implizit wegen Rekursion}
		\note[item]<3>{Type Parameter für jede Klasse}

		\item[Typenparametrisierung] F-Bounded Subtyping mit Matching
		\note[item]<4>{Parametrisierung}
	\end{bigdescription}
\end{frame}

\subsection{Rekursion}
\begin{frame}[c]{Rekursion}
	\begin{figure}
		\includedot[scale=0.7]{../../doc/dot/naiveRecursion}
		\caption{Naive Rekursion}
	\end{figure}
	\begin{figure}
		\includedot[scale=0.7]{../../doc/dot/mutualRecursion}
		\caption{Mututal Rekursion}
	\end{figure}
\end{frame}

\begin{frame}[c,fragile]{Rekursion}
\begin{lstlisting}[language=ooplss]
class A {
  def m(other: MyType): MyType { return m(other); }
}

class B subtypeOf A {
  def m(other: MyType): MyType { return A.m(other); }
}

class C subtypeOf B {
  def m(other: MyType): MyType { return B.m(other); }
}

class D subclassOf C {
  def m(other: MyType): MyType { return C.m(other); }
}
\end{lstlisting}
\end{frame}

\subsection{Typen-Parametrisierung}
\begin{frame}{Typen-Parametrisierung}
	\begin{bigitemize}{3mm}
		\item F-Bound mit Matching
		\note[item]{Matching kommt im F-Bound zum Einsatz}
	\end{bigitemize}
\end{frame}

\subsection{Übersetzung}
\begin{frame}{Übersetzung}
	\begin{bigitemize}{3mm}
		\item Direkte Übersetzung bei Extensions
		\item Kopieren bei Inheritance
		\item Parametrisierung ohne Type Erasures!
		\item Inheritance und Parametrisierung verwendet \emph{Name Mangling}
		\item Typen-Information zur Laufzeit
	\end{bigitemize}
\end{frame}

\subsection{Inferenzregeln}
\begin{frame}{Inferenzregeln}
\end{frame}
