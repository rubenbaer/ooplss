\chapter{Type Inference Rules}
\label{ctr:typeRules}
\section{Object Generation}
\section{Higher-Order Subtyping}
The following definitions for \emph{Oper} and \emph{Type} relation are
taken form \cite{steffen_higher-order_1994}.
\begin{table}[H]
	\begin{tabular}{lllr}
		\oper{X} & $\approx$ & X & \emph{(when X is match-bound)} \\
		\oper{$\mu X.\{\overline{l:T}, \overline{m:U\{X\}}\}$}
			& $\approx$
			& \multicolumn{2}{l}{$\lambda X.\{\overline{l:\text{\type{T}}}, \overline{m:\text{\type{U\{X\}}}}\}$} \\
		\type{X} & $\approx$ & X$^*$ & \emph{(when X is match-bound)} \\
		\type{$\mu X.\{\overline{l:T}, \overline{m:U\{X\}}\}$}
			& $\approx$
			& \multicolumn{2}{l}{$\mu X.\{\overline{l:\text{\type{T}}}, \overline{m:\text{\type{U\{X\}}}}\}$} \\
		\type{X} & $\approx$ & X & \emph{(when X is not match-bound)} \\
		\type{A $\rightarrow$ B} & $\approx$ & \multicolumn{2}{l}{\type{A} $\rightarrow$ \type{B}} \\
		\type{$\forall(X \mmatch A)B$} & $\approx$ & \multicolumn{2}{l}{$\forall(X \prec: \text{\oper{A}})$ \type{B}} \\
		A \match B & $\approx$ & \oper{A} $ \prec:$ \oper{B} & \emph{(for A, B object types)} \\
	\end{tabular}
\end{table}
Using these definitions implies reflexivity and transitivity for matching
since this is true for subtyping.
%
%\section{Type Generation}

\section{Type Rules}
For the sake of comprehensibility the following convention is used within
the type rules described in this section:

\begin{table}[H]
	\begin{tabular}{ll}
		\textit{Type Variables} & $X, Y, Z$ \\
		\textit{Type Arguments} & $T, U, V, W$ \\
		\textit{Constructor Type} & $K$ \\
		\textit{Object Types} & $A - E, G - J$ \\
		\textit{Field Type} & $F$ \\
		\textit{Method Types} & $M - P$ \\
		\textit{Type Boundary} & $N$
	\end{tabular}
\end{table}

For more compactness the following abbreviations and symbols are used; the
keywords \emph{subtypeOf} and \emph{subclassOf} are expressed with $\subt$
and $\subc$. The reflexive and transitive closure for subtyping and
subclassing is denoted by $\subtc$ and $\underline{\blacktriangleleft}$.
To specify a list of length $0\ldots n$ a over line is used, e.g.,
$\overline{X \mmatch N}$ is a list of match bounds.

Since type parameters are used, two environments are introduced. The
notion used within the type inference rules are similar to them from
\emph{Featherweight Java}\nomenclature{Featherweight Java}{A minimal
core calculus for Java and GJ}. `An environment $\Gamma$ is a finite
mapping from variables to types, written $\overline{x}:\overline{T}$;
a type environment $\Delta$ is a finite mapping from type variables to
nonvariable types, wirtten $\overline{X}<:\overline{N}$, which takes each
type variable to its bound' \cite{igarashi_featherweight_1999}. In contrast
to Featherweight Java, the bound is specified by \match and the bound is
specified by the type operator.

It is assumed that the implicit binding of \mytype is done as described
in \Cref{sec:implicitlyMyType} but made explicit, i.e., all necessary
parameters are introduced by the type combination to bind \mytype
correctly.

\begin{figure}[H]
 \fbox{
    \begin{minipage}{\linewidth}
			\paragraph{Subclassing:}
				\begin{mathpar}
					\inferrule*[right=SubC-Ref,rightskip=-1.0cm]
						{\\}
						{A \subcc A}
					\inferrule*[right=SubC-Trans]
						{B \subcc A\\C \subcc B}
						{C \subcc A} \\
					\inferrule*[right=SubC-Intro]
						{\text{class }A[\overline{X \mmatch N}] \subc B[\overline{T}] \{\ldots\}}
						{A \subcc B}
				\end{mathpar}

			\paragraph{Subtyping:}
				\begin{mathpar}
					\inferrule*[right=SubT-Ref,rightskip=-1.0cm]
						{\\}
						{A \subtc A}
					\inferrule*[right=SubT-Trans]
						{B \subtc A \\ C \subtc B}
						{C \subtc A} \\
					\inferrule*[right=SubT-Intro]
						{\text{class }A[\overline{X \mmatch N}] \subt B[\overline{T}] \{\ldots\}}
						{A \subtc B}
				\end{mathpar}
    \end{minipage}
  }
	\caption{Basic rules}
	\label{fig:basicRules}
\end{figure}

\begin{figure}[H]
 \fbox{
    \begin{minipage}{\linewidth}
			\paragraph{Field lookup:}
				\begin{mathpar}
					\inferrule*[right=F-Empty]
						{\text{class }A[X \mmatch N] \{ \}}
						{fields(A[T]) = \emptyset} \\
					\inferrule*[right=F-Class]
						{\text{class } A[\overline{X \mmatch N}]
								\subt B[\overline{T}]
								\subc C[\overline{U}] \{\overline{S f}; K \overline{M}\} \\\\
							fields([\overline{T / X}]B)=\overline{U g} \\\\
							fields([\overline{T / X}]C)=\overline{V h}}
						{fields(A[\overline{T}]) = \overline{U g}, \overline{V h}, [\overline{T / X}]\overline{S f} }
				\end{mathpar}

			\paragraph{Method type lookup:}
				\begin{mathpar}
					\inferrule*[right=MT-Class]
						{\text{class } A[\overline{X \mmatch N}]
								\subt B[\overline{T}]
								\subc C[\overline{U}] \{\overline{S f}; K \overline{M}\} \\\\
							\text{def } m(\overline{U x}): R \{ \ldots \} \in \overline{M}}
						{mtype(m, A[\overline{T}]) = [\overline{T/X}](\overline{U} \rightarrow R)} \\

					\inferrule*[right=MT-Supertype]
						{\text{class } A[\overline{X \mmatch N}]
								\subt B[\overline{T}]
								\subc C[\overline{U}] \{\overline{S f}; K \overline{M}\} \\\\
							m \in B[\overline{T}] \\ m \notin \overline{M}}
						{mtype(m, A[\overline{T}]) = mtype(m, [\overline{T/X}]B)}\\

					\inferrule*[right=MT-Superclass]
						{\text{class } A[\overline{X \mmatch N}]
								\subt B[\overline{T}]
								\subc C[\overline{U}] \{\overline{S f}; K \overline{M}\} \\\\
							m \in C[\overline{T}] \\ m \notin \overline{M}}
						{mtype(m, A[\overline{T}]) = mtype(m, [\overline{T/X}]C)}\\
				\end{mathpar}

			\paragraph{Method body lookup:}
				\begin{mathpar}
					\inferrule*[right=MT-Class]
						{\text{class } A[\overline{X \mmatch N}]
								\subt B[\overline{T}]
								\subc C[\overline{U}] \{\overline{S f}; K \overline{M}\} \\\\
							\text{def } m(\overline{U x}): R \{ e_i^n (n \in \mathbb{N}) \} \in \overline{M}}
						{mbody(m, A[\overline{T}]) = \overline{X}.[\overline{T/X}].e_i^n (n \in \mathbb{N})} \\

					\inferrule*[right=MT-Supertype]
						{\text{class } A[\overline{X \mmatch N}]
								\subt B[\overline{T}]
								\subc C[\overline{U}] \{\overline{S f}; K \overline{M}\} \\\\
							m \in B[\overline{T}] \\ m \notin \overline{M}}
						{mbody(m, A[\overline{T}]) = mbody(m, [\overline{T/X}]B)}\\

					\inferrule*[right=MT-Superclass]
						{\text{class } A[\overline{X \mmatch N}]
								\subt B[\overline{T}]
								\subc C[\overline{U}] \{\overline{S f}; K \overline{M}\} \\\\
							m \in C[\overline{T}] \\ m \notin \overline{M}}
						{mbody(m, A[\overline{T}]) = mbody(m, [\overline{T/X}]C)}\\
				\end{mathpar}

			\paragraph{Bound of types:}
					\[bound_\Delta(X) = \Delta(X) \]
					\[bound_\Delta(A) = A \]
    \end{minipage}
  }
	\caption{Auxiliary functions}
	\label{fig:auxFunctions}
\end{figure}

\begin{figure}[H]
 \fbox{
    \begin{minipage}{\linewidth}
			\paragraph{Subclassing:}
				\begin{mathpar}
					\inferrule*[right=Subclass-Ref,rightskip=-1.0cm]
						{\\}
						{\Delta \vdash A \mmatch A}
					\inferrule*[right=Subclass-Trans]
						{\Delta \vdash B \mmatch A \\ \Delta \vdash C \mmatch B}
						{\Delta \vdash C \mmatch A} \\
					\inferrule*[right=Subclass-Adopt,rightskip=-1.0cm]
						{\Delta \vdash B <: A \\ \Delta \vdash C \mmatch B}
						{\Delta \vdash C \mmatch A}
					\inferrule*[right=Subclass-Embed-SubT]
						{\Delta \vdash B <: A}
						{\Delta \vdash B \mmatch A} \\
					\inferrule*[right=Subclass-Var]
						{\\}
						{\Delta \vdash X \mmatch \Delta(X)} \\
					\inferrule*[right=Subclass-Class]
						{\text{class }X[\overline{X \mmatch N}] \subt B \subc C \{\ldots\}}
						{\Delta \vdash A[\overline{T}] \mmatch [\overline{T/X}]B\\
						\Delta \vdash A[\overline{T}] \mmatch [\overline{T/X}]C}
				\end{mathpar}

			\paragraph{Subtyping:}
				\begin{mathpar}
					\inferrule*[right=Subtype-Ref,rightskip=-1.0cm]
						{\\}
						{\Delta \vdash A <: A}
					\inferrule*[right=Subtype-Trans]
						{\Delta \vdash B <: A \\ \Delta \vdash C <: B}
						{\Delta \vdash C <: A} \\
					\inferrule*[right=Subtype-Class]
						{\text{class }X[\overline{X \mmatch N}] \subt B \subc C \{\ldots\}}
						{\Delta \vdash A[\overline{T}] <: [\overline{T/X}]B}
				\end{mathpar}
		\end{minipage}
	}
	\caption{Type relation rules}
	\label{fig:typeRelationsRules}
\end{figure}

\begin{figure}[H]
 \fbox{
    \begin{minipage}{\linewidth}
			\paragraph{Well-formed types:}
				\begin{mathpar}
					\inferrule*[right=WF-Env,rightskip=-1.0cm]
						{\\}
						{\Delta \vdash ok}
					\inferrule*[right=WF-VarType]
						{X \in dom(\Delta)}
						{\Delta \vdash X~ok}\\
					\inferrule*[right=WF-Class]
						{\text{class }A[\overline{X \mmatch N}]
								\subt B
								\subc C \{\ldots\}\\\\
							\Delta \vdash \overline{T}~ok \\
							\Delta \vdash \overline{T \mmatch [\overline{T/X}]N}
						}
						{\Delta \vdash C[\overline{T}]~ok}
				\end{mathpar}
		\end{minipage}
	}
	\caption{Wellformed type rules}
	\label{fig:wellformed}
\end{figure}

\begin{figure}[H]
 \fbox{
    \begin{minipage}{\linewidth}
			\paragraph{Expression typing:}
				\begin{mathpar}
					\inferrule*[right=Var]
						{\\}
						{\Delta; \Gamma \vdash x : \Gamma(x)} \\
					\inferrule*[right=Field]
						{\Delta; \Gamma \vdash e_i : T_i \\ fields(bound_\Delta(T_i)) = \overline{T f}}
						{\Delta; \Gamma \vdash e_i.f_j : T_j} \\
					\inferrule*[right=Invk]
						{\Delta; \Gamma \vdash e_i : T_i \\\\
							mtype(m, bound_\Delta(T_i)) = \overline{U} \rightarrow U \\\\
							\Delta; \Gamma \vdash \overline{e : S} \\ \Gamma \vdash \overline{S <: U}}
						{\Delta; \Gamma \vdash e_i.m(\overline{e}) : U} \\
					\inferrule*[right=New]
						{\Delta \vdash N~ok \\
							fields(N) = \overline{T f} \\
							\Delta; \Gamma \vdash \overline{e : S} \\
							\Delta \vdash \overline{S <: T}}
						{\Delta; \Gamma \vdash new N(\overline{e}) : N}
				\end{mathpar}
		\end{minipage}
	}
	\caption{Expression type rules}
	\label{fig:expressionRuleexpressionRules}
\end{figure}

%\begin{figure}[H]
% \fbox{
%    \begin{minipage}{\linewidth}
%		\end{minipage}
%	}
%	\caption{Subtyping type rules}
%	\label{fig:subtypingRules}
%\end{figure}

%\begin{itemize}
%\item Product Introduction
%\item Product Elimination
%\item Function Introduction
%\item Function Elimination
%\item Record Introduction
%\item Record Elimination
%\item Record Subtyping
%\item Function Subtyping
%\item Product Subtyping
%\item Record Extension
%\item Record Overriding
%\item Recursive Subtype
%\item Subclass
%\item Classify
%\end{itemize}
