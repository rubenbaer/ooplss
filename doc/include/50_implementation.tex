\chapter{Implementation}

\begin{figure}[H]
	\centering
	\begin{emp}[classdiag](20, 20)
	Class.SymbolTable("SymbolTable")()();

	Class.Scope("Scope")("enclosingScope:Scope")( "define(Symbol):Void", 
			"resolve(String):Symbol", "resolveType():Type");
	classStereotypes.Scope("<<interface>>");
	Scope.ne = SymbolTable.sw + (-60, -10);

	AbstractClass.Symbol("Symbol")("def:OoplssAST", "type:Type", "scope:Scope")("");
	Symbol.n = SymbolTable.s + (0, -10);

	drawObjects(SymbolTable, Scope, Symbol);

	Class.BaseScope("BaseScope")()();
	BaseScope.n = Scope.s + (0, -20);

	Class.GlobalScope("GlobalScope")()();
	GlobalScope.n = BaseScope.s + (-40, -20);

	Class.LocalScope("LocalScope")()("define(Symbol):void");
	LocalScope.n = BaseScope.s + (0, -80);

	drawObjects(BaseScope, LocalScope, GlobalScope);
	link(implements)(BaseScope.n -- Scope.s);
	link(inheritance)(LocalScope.n -- BaseScope.s);
	link(inheritance)(pathManhattanY(GlobalScope.n, BaseScope.w));

	AbstractClass.ScopedSymbol("ScopedSymbol")()();
	ScopedSymbol.n  = Symbol.s + (0, -30);

	drawObjects(ScopedSymbol);
	link(inheritance)(ScopedSymbol.n -- Symbol.s);
	link(implements)(pathManhattanY(ScopedSymbol.nw, Scope.se));

	Class.MethodSymbol("MethodSymbol")("arguments:List", "origin:MethodSymbol")();
	MethodSymbol.n = ScopedSymbol.s + (-60, -30);
	link(inheritance)(pathManhattanY(MethodSymbol.n, ScopedSymbol.w));

	Class.ClassSymbol("ClassSymbol")
		("supertype:ClassSymbol", "superclass:ClassSymbol", "constructor:MethodSymbol")
		("resolve(String):Symbol", "resolveMember(String):Symbol",
		"resolveSuper(String):Symbol", 
		"checkMethodArguments():boolean", "checkMethodReturnTypes():boolean",
		"checkForInheritanceErrors(:boolean)", "checkForOverridings():void",
		"isSubtypeOf(ClassSymbol):boolean", "isSubclassOf(ClassSymbol):boolean");
	ClassSymbol.n = ScopedSymbol.s + (0, -80);

	Class.Type("Type")()();
	classStereotypes.Type("<<interface>>");
	Type.w = ClassSymbol.e + (40, 0);

	drawObjects(MethodSymbol, ClassSymbol, Type);
	link(inheritance)(ClassSymbol.n -- ScopedSymbol.s);
	link(implements)(ClassSymbol.e -- Type.w);


	Class.VariableSymbol("VariableSymbol")()();
	VariableSymbol.w = Symbol.e + (40, 0);

	Class.BuiltIn("BuiltInTypeSymbol")()();
	BuiltIn.nw = Symbol.se + (40, -30);

	AbstractClass.SpecialSymbol("SpecialSymbol")()();
	SpecialSymbol.nw = BuiltIn.s + (0, -20);

	Class.ConstructorType("ConstructorType")()();
	ConstructorType.n = SpecialSymbol.se + (5, -30);

	drawObjects(VariableSymbol, BuiltIn, SpecialSymbol, ConstructorType);
	link(inheritance)(VariableSymbol.w -- Symbol.e);
	link(inheritance)(BuiltIn.nw -- Symbol.s);
	link(implements)(pathStepY(BuiltIn.sw, Type.nw, -70));
	link(inheritance)(pathStepX(SpecialSymbol.e, Symbol.se, 10));
	link(implements)(pathStepY(SpecialSymbol.sw, Type.n, -20));
	link(inheritance)(pathStepY(ConstructorType.n, SpecialSymbol.s, 5));





	\end{emp}
	\caption{Classes of the symbol table}
	\label{fig:classes}
\end{figure}

\section{Design}
This chapter contains a description of the general compiler. Figure
\ref{fig:compilerPhase} shows the different parts of the whole compiler
software. There is a section describing each phase.

\begin{figure}[ht]
	%\centering
	\centerline{\includedot[scale=0.5]{dot/compilerDesign}}
	\caption{Compiler phases}
	\label{fig:compilerPhase}
\end{figure}

The compiler of \ooplss is written in Java using
ANTLR as parser generator. ANTLR supports the generation of code for the lexical
and semantical analysis, which then generates an abstract syntax tree for
the intermediate representation of the input. In ANTLR it is possible to
define both, grammars for string, 1-dimensional, and for
abstract syntax trees which are 2-dimensional. In ANTLR these are known
as \emph{tree grammars} which are similar to normal grammars but matches
abstract syntax tree nodes and not lexer tokens. The lexer and parser
part is a normal grammar whereas the other phases are all tree grammars
which are used for tree rewriting.
\todo{The tree is actually only rewritten once, when generating the AST... or what
is it you mean}
The output process is supported by
\st, a project associated to ANTLR.

However, every phase of this compiler design is independent and can 
replaced arbitrarily. This makes corrections within this parts easy and
does not automatically break the whole interface between the compiling
phases. Even new phases can be injected between two phases which may 
perform some further analysis or code optimisation.

Even though ANTLR supports different output languages for the parser, Java was
chosen and consequently the whole compiler is written in Java. Mixing
the implementation language would unnecessarily increase the effort
by providing a uniform interface from ANTLR code and the implementation
language.

The output translation backend is a translation unit from the
intermediate abstract syntax tree to pure Java code.

\subsection{Software Structure}

Package diagram

Important class diagrams

\subsection{Lexer and Parser}
The lexer and parser are both in the same file \emph{Ooplss.g} defined
since they are strongly connected together. 

The lexer creates tokens which are fed to the parser. It simply
analyses every character in the input string and tries to identify tokens
that are used in the parser. Some tokens like comments and whitespace characters 
are skipped and not passed to the parser.

The parser parses the tokens from left to right and creates a left most
derivation with a lookahead of two, this is shortly known as LL(2) parser.
All this is done from top to bottom and produces  an 
abstract syntax tree (AST). To make the debugging
process of the parser code simpler, the lookahead is limited to two although ANTLR
would support arbitrary lookahead.

After this phase an abstract syntax tree is generated and ready to be visited
and to be operated on. The AST already contains the correct operator precedence.

\subsection{Symbol Table Building}
The first part that operates on the abstract syntax tree is the building of
the symbol table. This is divided into two separated compiler runs: the
first identifies every symbol definition like classes, methods and
variables used within a program. Since fields can be declared anywhere
in a class two separate runs are necessary, one to track all the defined
symbols and one to resolve the types, method calls and variable accesses.

The symbol table has four different scope levels. These scopes are nested
and child scopes can access the symbols in the parent scope.
\begin{description}
	\item[Global scope] All classes and built-in types
	\item[Class scope] All fields of a specific class
	\item[Method scope] The method parameters and variables
	\item[Local scope] Local scopes within a method. These scopes
	constrain the validity of local defined variables
\end{description}

\subsubsection{Built-Ins}
Built-In symbols are created before walking the tree for the first time.
They are assigned to the global scope.

\subsubsection{Define Symbols}
The first phase of the symbol table building is the definition run or
walk.  Every single class, method and scope is visited with the depth
first strategy and tracks every symbol definition. The tree grammar for
this can be found in the file \emph{OoplssDef.g}. Every time a scope
is entered, this scope is set as the current scope and the one before
is saved as the parent scope.  Like this, all symbol definitions are
recorded in the according scope.  Additionally, the current scope is
recorded to some AST nodes for later referencing.

If a symbol is already defined within the current scope and clashes with
an existing one, an exception is thrown.

After this phase a symbol table is created for the whole program where
every symbol in every scope is tracked. The table is in reality a tree
which can resolve every valid symbol within a scope.


\subsubsection{Referencing Symbols}
In the second phase, the referencing run, mainly every use of a symbol that is 
not declarative (method call, variable access, super type declaration, types 
in declarations etc.) is examined and resolved to the according symbol definition. 
Exceptions are thrown on errors like accessing non-existent variables, calling 
variables or using types that don't exist.
\todo{does this need to be precise?}

All of this is possible due to the fact that now all definitions are known and available
in the tree.

There are different types of resolving the symbols:
\begin{description}
\item[Variable referencing]
Just walks up the scope tree to find the symbol 
\item[Method calling]
The same as variable referencing but it has to be a method symbol
\item[Member accessing]
Is used when class fields are accessed like x.f; or x.foo();. First it checks
if the field really is accessed on a class. If not, an according exception
is thrown. If this is the case, it is checked if a field with such name exists
in the class. Opposed to normal variable referencing, the search does not walk
the scope tree upwards, instead, it tries to resolve the names in the super classes
and scopes if not found.
\item[Type resolving]
The same as variable referencing but it also checks whether it's a type or not.
\item[Special type resolving]
Resolves special symbols directly in the global scope
\item[Class resolving (new statement)]
The same as type resolving but it has to be a user defined class
\todo{which is wrong, see issue 47}
\item[Self resolving]
Resolves to the enclosing class
\end{description}

The referencing phase also does some special tasks:
\begin{itemize}
\item it checks whether a symbol that was not declared in the class scope is defined 
before being accessed for the first time because forward referencing is only 
allowed for class fields.
\item upon leaving a class it checks if there are symbols that override symbols
declared in super classes or super types. This cannot be done in the definition run
because only now there is a reference to the super type/class.
\item when referencing a super type or class it also runs some checks to avoid
cyclic subtyping or subclassing.
\end{itemize}

The result of this phase is a fully propagated symbol table. Every symbol can
now be resolved within this tree with all necessary meta data. The tree grammar
for the reference walker is defined in \emph{OoplssRef.g}

\subsection{Type Checking}

The third walk on the abstract syntax tree does the type checking. This
time the nodes are evaluated in postorder so both sides of an expression
node are evaluated before the node itself is evaluated. Like this the
evaluated types are promoted upwards the tree until a violation of the
typing rules is found.

The basic concept of the type checker is to check if method arguments, 
both sides of an expression/assignment etc. have the same type. In case
of basic types this is a bit extended since adding a integer to a float 
is perfectly valid. In this case, the type checker yields float as evaluation
type of the addition expression.

In case of method arguments, return statements, new object creation 
and assignments it is extended as well since the subtyping concept 
allows assigning values that are of a subtype of the expected value.

The typing rules are explained in detail in \Cref{ctr:typeRules}. The
type checker grammar can be found in \emph{OoplssTypes.g}

\subsubsection{Decidability}
\Cref{ctr:typeRules}

\subsection{Standalone statements}

Since \ooplss is translated into Java, there has to be some checking
done on the statements so the compiler doesn't create erroneous Java
code. Java has some constraints, for instance meaningless statements
like accessing a variable without assigning it to another variable
or passing it to a function is inhibited by the Java compiler.

We solved this particular problem by assigning every statement whether
it is allowed to stand alone or not. Then the reference walker loops 
through all statements upon leaving a block. If one is found that cannot
stand alone, an exception is thrown.

\subsection{Translation}
Translation is the last stage of the compiler backend. It
translates an abstract syntax tree which is type checked to the
output language -- Java. The last tree grammar can be found in the
file \emph{OoplssGen.g}. Again, a tree grammar is used to perform the
translation.

The code translation is template driven, i.e., appropriate templates
were created which cover the used language structures in Java. The
templates are written in \st which is a dynamically typed and functional
programming language. Matches in the abstract syntax tree does directly
call a template which generates appropriate code. The detailed syntax
equivalence of \ooplss to Java is described in \Cref{ctr:translation}.

As result the intermediate language representation is translated to the
output Java code which runs on the Java Virtual Machine.

\section{Translation}
\label{ctr:translation}
This chapter deals with the exact translation from \ooplss code segments
to Java.

Done to java as seen in part III
% estimated pages: 10

\todo{Export code and intermediate code in X\$\$...}

\section{Unit Testing}
\subsection{gUnit -- A Grammar Testing Framework}

To be able to run unit tests on the grammar, the gUnit
\footnote{\href{http://www.antlr.org/wiki/display/ANTLR3/gUnit+-+Grammar+Unit+Testing}
{http://www.antlr.org/wiki/display/ANTLR3/gUnit+-+Grammar+Unit+Testing}}
feature of ANTLR is used. gUnit tests can be run directly on the grammar files.

There are two types of testing: simple grammar checks and AST checks. The 
first simply checks whether the input yields an error or not. This is useful
to test if valid input code is accepted and erroneous code rejected. The
second type is to check whether the AST tree is rewritten correctly. It is 
possible to write the expected AST for every rule in the grammar.\\

The gUnit tests can be found in \emph{grammar/test/}.


\subsection{JUnit}

The symbol table is checked via JUnit tests. There are various tests that 
test the symbol table in a certain depth, i.e. the definition walker, the
reference walker and the type checker.

\subsection{Examples}
see \Cref{ctr:exampleCode}
% estimated pages: 5
