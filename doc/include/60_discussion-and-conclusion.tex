\chapter{Comparison with Scala}
%\ooplss:Scala -- A Contrasting Juxtaposition
\label{sec:comparisonScala}
This chapter presents a comparison of some features of Scala and \ooplss.

INTRODUCTION

\section{Scala -- A Scalable Language}
Scala is a modern programming language initiated by Martin Odersky,
director of \emph{Laboratoire de Méthodes de programmation} at the
\emph{école polytechnique fédérale de Lausanne}. It is a general
purpose programming language with special remarks on scalability
and flexibility without dropping the advantages of a static type
system. Scala provides a multi-paradigm language with support for
object-oriented and functional programming. As target platform both JVM
and CLR\footnote{Commmon Language Runtime is the run-time environment
for Microsoft's .NET technology} can be chosen by the programmer. These
platforms are seamless integrated to Scala which enables the use of
existing software and libraries available on these platforms.

During the development of Scala a special remark on the type system
was given. Consequently it contains many different features that
found not respectively rarely its way into popular languages with
static type systems like abstract type definitions in abstract
classes, explicitly typed self references and traits, software
units for proper code reuse.  Anyway, these are not all the
special features within Scala. Further informations are available in
\cite{odersky_scala_2010,odersky_programming_2008} or on its website
\href{http://www.scala-lang.org/}{www.scala-lang.org}.

\section{Abstract Types and Explicitly Typed Self References}
%Abtract Types and Explicit Self Typig
%Explicit self typing
A common concept which is available in many popular object-oriented
programming languages is the definition of abstract classes which
provides a partial implementation of a class. Such classes can not be
instantiated by the user but specialised to concrete classes with a full
implementation.  In many implementation of this feature, e.g., in C++,
\cs or D, only abstract methods and properties are supported. Scala goes
one step further and adds abstract type definitions. An abstract type
can be used simply as normal type declaration within this class. At last
at the moment where the abstract class is derived to a concrete class
these type declarations have to be specified with an existing type.

\begin{lstlisting}[float,language=scala,caption=Abstract type declaration in Scala,label=lst:abstractType]

\end{lstlisting}

\section{Software Composition with Traits}
%Traits, Existential types


\chapter{Discussion and Conclusion}
\section{Discussion}
\label{ctr:discussion}
The discussion contains three section. The first takes the examples from
\Cref{ctr:theoreticalBackground} into account and how they are expressed
in \ooplss. It is shown how these problems can be models in a better
way for some situations and how the programmer is supported. Here, it
is considered that the full specification is implemented. The following
section makes then a comparison with Scala an does shortly presents how
these problems are treated within Scala and where the major differences
are. The fact that the implementation is not thus far as the specification
is discussed in the last section and presents the status quo of \ooplss'
implementation.

\subsection{Solving prior Problems with \ooplss}
In \Cref{chap:subtypingVsSubclassing} three different examples were
introduced where subtyping forces the programmer to write code that
needs unsafe type casts and runtime checks.

\subsubsection{The Circle - Ellipse Problem}
This example is introduced in \Cref{sec:sharingTypes} where the type
hierarchy differs from implementation. The question is whether an ellipse
is a specialisation from an circle or the other way round.

To consider this example, both definitions of subtyping may be recalled;
In signature subtyping, which is supported by \ooplss, gives the
definition that a subtype can only add but not remove fields. With this,
an ellipse can be a subtype of a circle since an ellipse has two radii,
i.e., has at least one more field then a circle. In behavioural subtyping
the subtypes invariants can only be more restrictive. Here a circle is
a subtype of an ellipse since both radii of an ellipse must be equals
to define a circle.

However, the problem in signature subtyping is that the runtime behaviour
of this model is incorrect, e.g., an circle object that references a
runtime ellipse object would return a wrong result for the height and
width properties and consequently a wrong area etc. For this problem
exists different approaches tackling this problem. One of this is to
decouple both types and implementation completely. Unfortunately this
leads to massively redundant code which of course can be reduced with
various techniques like multiple inheritance and abstract base classes. A
more straightforward solution is now presented in \ooplss in Listing
\ref{lst:ellipseCircleOoplss} using subclasses. Although subsumption
is not not available the code of Circle could be reused and with the
matching relation, new parametrised classes can get introduced that can
handle with both classes properly even when they are not interchangeable.

\begin{lstlisting}[float,language=ooplss,caption=Circle-Ellipse problem in \ooplss,label=lst:ellipseCircleOoplss]
class Circle {
	var width : Float;
	def setWidth(widht : Float) : Void { self.width = widht; }
	def area() : Float { return width * width * 3.1415; }
	def width() : Float { return width; }
}

class Ellipse subclassOf Circle {
	def area() : Float { return 3.1415 * width * height; }
	var height : Float;
	def setHeight(r : Float) : Void { self.height = r; }
	def height() : Float { return self.height; }
}
\end{lstlisting}

\subsubsection{Cats and Dogs and Linked Lists}
The example presented in \Cref{sec:recursiveClosure} deals with the
problem of binary methods and consequently with object families. 

In the first case are binary methods considered. In a subtyping environment
binary methods arguments are not changeable with the type hierarchy. This
entails that when a programmer wants to implement these binary methods,
unsafe type checks and casts are inevitable. A well known problem is the
equals method like in Java or \cs. Before two objects can be compared
for equality runtime type checking is necessary although passing other
object types would not make any sense.

The second case is strongly connected with binary methods and this
restriction for subtyping. It deals with the implementation of multiple
object hierarchies with a strong connection between them. There are two
examples that presents this very well. First, suppose simultaneously to
an element object hierarchy an hierarchy of operations are defined. For 
the \emph{visitor pattern} by Erich Gamma et al. \cite{gamma_design_1995}
is a good solution for a pure subtyping environment and where subsumption
is important. However, if the operations are designed for homogeneous
data structures this has a drawback. If the element hierarchy changes all
visitors need to be changed which is maybe not possible everywhere. Here
subclassing is may be more appropriate. \Cref{fig:operationFamily}
presents this idea. With an appropriate parametrisation of the operation
classes it is possible to defined appropriate operations for every object.

\begin{figure}[H]
	\centering
	\begin{emp}[classdiag](20, 20)
		Class.AnimalA("Animal")()("mate(Animal): Animal");
		Class.DogA("Dog")()("mate(Dog): Dog");
		Class.CatA("Cat")()("mate(Cat): Cat");

		DogA.ne = AnimalA.s + (-10, -35);
		CatA.nw = AnimalA.s + (10, -35);

		drawObjects(AnimalA, DogA, CatA);
		link(subclassof)(DogA.n -- AnimalA.s);
		link(subclassof)(CatA.n -- AnimalA.s);

		Class.AnimalOp("AnimalOperation[T<#Animal]")()("do(T): T");
		Class.DogOp("DogOperation[T<#Dog]")()("do(T): T");
		Class.CatOp("CatOperation[T<#Dog]")()("do(T): T");

		AnimalOp.w = AnimalA.e + (100, 0);
		DogOp.ne = AnimalOp.s + (-10, -35);
		CatOp.nw = AnimalOp.s + (10, -35);

		drawObjects(AnimalOp, DogOp, CatOp);
		link(subclassof)(DogOp.n -- AnimalOp.s);
		link(subclassof)(CatOp.n -- AnimalOp.s);
	\end{emp}
	\caption{Animal type family with operations on each concrete element}
	\label{fig:operationFamily}
\end{figure}

This idea can easily adopted to the problem of SinglyLinkedNodes
and DoublyLinkedNodes which is presented in Section
\ref{subsec:matching}. Consequently the node family specifies an element
family where an appropriate list class family does implement appropriate
algorithms for efficient list using.

\subsubsection{Schizophrenic Self References}
The last example considered in this chapter deals with schizophrenic self
references in extension which are introduced in \Cref{sec:schizoReferences}.

This is the most obvious example affected by subclassing and \mytype. 

\begin{lstlisting}[float,language=ooplss,caption=Avoid schizophrenic self references with \mytype.,label=lst:solveSchizo]
class Vec2D {
	var x : Int;
	var y : Int;
	def identity : MyType {
		return self;
	}
	def equals(vec : MyType) : Bool {
		return vec.x == self.x && vec.y = self.y;
	}
}

class Vec3D subclassOf Vec2D {
	var z : Int;

	def equals(vec : MyType) : Bool {
		return base.equals(vec) && self.z == vec.z;
	}
}
\end{lstlisting}

\subsection{Status Quo of Implementation within Project}
\label{sec:statusQuo}

\section{Further Work}
\label{sec:futureWork}
In projects like this one, where years of development could be used for
further improvements and new techniques. Some of these points are here
discussed. The section is divided into two fields.  One presents some
possible language extensions and the other some implementation details
which would improve a proper use of the language.

\subsection{Language Extensions}
This section presents some possible extensions for the core language
independently of the implementation. The order presented is not weighted
in the sense of its importance. To raise the language to a language
of wide use all these extensions should be considered as important.

\subsubsection{Pure Object Orientation}
For an straightforward use of numbers and strings with all its available
operators they are implemented as primitive data types. This makes the 
implementation easier since the operations does not have to be translated
to method calls. But this makes then a special treatment of these types
and less extensional since these operators are only available for these 
types. For a more coherent language these native operators and types could
be dropped for a more sophisticated language where these operators can be
implemented by arbitrary classes. This would have the advantage that it
would became a pure object oriented language that would not distinguish
between two different types.

\subsubsection{Information Hiding}
Currently, \ooplss does not know any kind of access modifiers like
\emph{public}, \emph{protected} and \emph{private}. With this is no
information hiding possible which does only provide an object's interface
and not all internal variables and data. For a proper isolation of
internal states and external representation such modifiers should be
introduced. An other possibility would be to give the programmer the
possibility to define a specific visible type declaration and a class
declaration.

\subsubsection{Method Overloading and Multiple Extension}
Actually method overloading is not integrated in \ooplss. With this
comes several problems which could be avoided. On one hand, it is currently
not possible to provide multiple inheritance since methods overloading is
essential for usable class combination. Now, the language is restricted
that extension is only allowed as long as no method overloading occurs.
This change can be considered as straightforward since the exact definition
which method should be called is already possible with full parent
specification by the caller. The current restriction is in many problems
annoying and is just a simplification since it is not a core problem which
is treated in this thesis project.

\subsubsection{Modularisation}
Modularisation is also missing. Today only very monolithic programs
are possible where no separate compilation units are supported. For larger
programs this would increase compilation time and a flexible work between
developer teams is not supported. This makes \ooplss in its current state
useless for serious programs although the target platform is widely
used. Hand in hand supporting multiple files would be inevitable and
necessary for future developments.  Even simple modularisation would be
not very difficult a more sophisticated form is proposed where modules are
higher-order constructs and can be parametrised \cite{dreyer_type_2003}.

However, with the introduction of proper subclasses a simple form of
modularisation and code reuse is already provided. With this adding
existing code to classes is very simple and safe.

\subsubsection{Interfaces}
In addition to information hiding with access modifiers and information
hiding a sort of interfaces or abstract classes can be introduced. In 
contrast to this would be the introduction of a flexible modularisation
with the possibility to define an external interface.

\subsubsection{Top and Bottom Types}
The language design has a similarity to that of C++ which does
not have an implicitly superclass comparing to Java and \cs. With this
comes one drawback that it is not possible to write methods that accept
arbitrary objects if not a own superclass is specified and explicitly
extended. This decision is made because two class combinations are
possible and an implicit base class would force the programmer to one
of them at the very beginning of every class. 

Anyway, one proposal to enable the possibility of passing respectively
returning arbitrary objects would be to introduce a special \emph{Top}
type which contains every possible type. The idea is similar to an
\emph{Object} type but without any \mytype and recursive fields. Actually
it is free to every programmer to introduce an own type which is used 
as general base type.

%\subsubsection{Higher-Order Functions}

\subsection{Further Implementation Work}
In contrast to \Cref{sec:futureWork} this section deals with work that
would not change the language but would make the language more useful
for daily work.

\subsubsection{Implementing the Specification}
As presented in \Cref{sec:statusQuo} the compiler does not provide the
full language which was specified. This would be the next step in the 
implementation that should be done since parametrisation is not supported
yet.

\subsubsection{JDK Integration}
Considering the fact that the \ooplss is not fix defined on the current
target platform of the JDK, it would be nevertheless interesting to
improve the integration into the target platform. With this a widely
known and enormous framework would automatically get available to
\ooplss programmers. The problem of this extension would be to integrate
both derivation possibilities which is different to Java. However,
this would may come hand in hand with the direct translation to JDK
Bytecode which is more flexible then the Java language. 

\subsubsection{Subclassing with Dynamic Invokes}
The translation from \ooplss to Java is now not very straightforward since
explicit class combinations are necessary. However in JDK 7 which will
be released in summer 2011 the JDK will get some major changes. One 
of this is the introduction of the \emph{dynamicinvoke} command on 
Bytecode level. This would support dynamically typed language on the
platform where the most suitable method would be called depending on the
runtime type of the parameter types. Since \ooplss has an own type
checker it would be safe to use dynamic code. With a dynamic method 
lookup the subclassing relation would be much more simple.

\subsubsection{Type Inference}
In many cases the types of a method or variable can be predicted 
by the type system with a type inference algorithm. This helps 
the programmer to write less and provide more compact and readable
programs. Without changing \ooplss' semantic, such type inference
could be implemented as a next further step.

\section{Conclusion}
\label{ctr:conclusion}
%estimated pages: 2
