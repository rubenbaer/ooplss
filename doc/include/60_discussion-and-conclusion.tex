\chapter{Discussion and Conclusion}
\section{Discussion}
\label{ctr:discussion}

INTRODUCTION \todo{Intro}

\subsection{Solving prior Problems with \ooplss}
In \Cref{chap:subtypingVsSubclassing} three different examples were
introduced where subtyping forces the programmer to write code that
needs unsafe type casts and runtime checks.

\subsubsection{The Circle - Ellipse Problem}
This example is introduced in \Cref{sec:sharingTypes} where the type
hierarchy differs from implementation. The question is whether an ellipse
is a specialisation from an circle or the other way round.

To consider this example, both definitions of subtyping may be recalled;
In signature subtyping, which is supported by \ooplss, gives the
definition that a subtype can only add but not remove fields. With this,
an ellipse can be a subtype of a circle since an ellipse has two radii,
i.e., has at least one more field then a circle. In behavioural subtyping
the subtypes invariants can only be more restrictive. Here a circle is
a subtype of an ellipse since both radii of an ellipse must be equals
to define a circle.

However, the problem in signature subtyping is that the runtime behaviour
of this model is incorrect, e.g., an circle object that references a
runtime ellipse object would return a wrong result for the height and
width properties and consequently a wrong area etc. For this problem
exists different approaches tackling this problem. One of this is to
decouple both types and implementation completely. Unfortunately this
leads to massively redundant code which of course can be reduced with
various techniques like multiple inheritance and abstract base classes. A
more straightforward solution is now presented in \ooplss in Listing
\ref{lst:ellipseCircleOoplss} using subclasses. Although subsumption
is not not available the code of Circle could be reused and with the
matching relation, new parametrised classes can get introduced that can
handle with both classes properly even when they are not interchangeable.

\begin{lstlisting}[float,language=ooplss,caption=Circle-Ellipse problem in \ooplss,label=lst:ellipseCircleOoplss]
class Circle {
	var width : Float;
	def setWidth(widht : Float) : Void { self.width = widht; }
	def area() : Float { return width * width * 3.1415; }
	def width() : Float { return width; }
}

class Ellipse subclassOf Circle {
	def area() : Float { return 3.1415 * width * height; }
	var height : Float;
	def setHeight(r : Float) : Void { self.height = r; }
	def height() : Float { return self.height; }
}
\end{lstlisting}

\subsubsection{Cats and Dogs and Linked Lists}
The example presented in \Cref{sec:recursiveClosure} deals with the
problem of binary methods and consequently with object families. 

In the first case are binary methods considered. In a subtyping environment
binary methods arguments are not changeable with the type hierarchy. This
entails that when a programmer wants to implement these binary methods,
unsafe type checks and casts are inevitable. A well known problem is the
equals method like in Java or \cs. Before two objects can be compared
for equality runtime type checking is necessary although passing other
object types would not make any sense.

The second case is strongly connected with binary methods and this
restriction for subtyping. It deals with the implementation of multiple
object hierarchies with a strong connection between them. There are two
examples that presents this very well. First, suppose simultaneously to
an element object hierarchy an hierarchy of operations are defined. For 
the \emph{visitor pattern} by Erich Gamma et al. \cite{gamma_design_1995}
is a good solution for a pure subtyping environment and where subsumption
is important. However, if the operations are designed for homogeneous
data structures this has a drawback. If the element hierarchy changes all
visitors need to be changed which is maybe not possible everywhere. Here
subclassing is may be more appropriate. \Cref{fig:operationFamily}
presents this idea. With an appropriate parametrisation of the operation
classes it is possible to defined appropriate operations for every object.

\begin{figure}[H]
	\centering
	\begin{emp}[classdiag](20, 20)
		Class.AnimalA("Animal")()("mate(Animal): Animal");
		Class.DogA("Dog")()("mate(Dog): Dog");
		Class.CatA("Cat")()("mate(Cat): Cat");

		DogA.ne = AnimalA.s + (-10, -35);
		CatA.nw = AnimalA.s + (10, -35);

		drawObjects(AnimalA, DogA, CatA);
		link(subclassof)(DogA.n -- AnimalA.s);
		link(subclassof)(CatA.n -- AnimalA.s);

		Class.AnimalOp("AnimalOperation[T<#Animal]")()("do(T): T");
		Class.DogOp("DogOperation[T<#Dog]")()("do(T): T");
		Class.CatOp("CatOperation[T<#Dog]")()("do(T): T");

		AnimalOp.w = AnimalA.e + (100, 0);
		DogOp.ne = AnimalOp.s + (-10, -35);
		CatOp.nw = AnimalOp.s + (10, -35);

		drawObjects(AnimalOp, DogOp, CatOp);
		link(subclassof)(DogOp.n -- AnimalOp.s);
		link(subclassof)(CatOp.n -- AnimalOp.s);
	\end{emp}
	\caption{Animal type family with operations on each concrete element}
	\label{fig:operationFamily}
\end{figure}

This idea can easily adopted to the problem of SinglyLinkedNodes
and DoublyLinkedNodes which is presented in Section
\ref{subsec:matching}. Consequently the node family specifies an element
family where an appropriate list class family does implement appropriate
algorithms for efficient list using.

\subsubsection{Schizophrenic Self References}
The last example considered in this chapter deals with schizophrenic self
references in extension which are introduced in \Cref{sec:schizoReferences}.

This is the most obvious example affected by subclassing and \mytype. 

\begin{lstlisting}[float,language=ooplss,caption=Avoid schizophrenic self references with \mytype.,label=lst:solveSchizo]
class Vec2D {
	var x : Int;
	var y : Int;
	def identity : MyType {
		return self;
	}
	def equals(vec : MyType) : Bool {
		return vec.x == self.x && vec.y = self.y;
	}
}

class Vec3D subclassOf Vec2D {
	var z : Int;

	def equals(vec : MyType) : Bool {
		return base.equals(vec) && self.z == vec.z;
	}
}
\end{lstlisting}

\subsection{Status Quo of Implementation within Project}

\subsection{Comparison with Scala}
\label{sec:comparisonScala}
% estimated pages: 6$

Explicit self typing

Existential types

\subsection{Future Work}
\label{sec:futureWork}
In projects like this one, where years of development could be used for
further improvements and new techniques. Some of these points are here
discussed. The section is divided into two fields.  One presents some
possible language extensions and the other some implementation details
which would improve a proper use of the language.

\subsubsection{Language Extensions}

\paragraph{Information Hiding}

\paragraph{Interfaces}

\paragraph{Method Overloading and Multiple Inheritance}
Actually method overloading is not integrated in \ooplss. With this
comes several problems which could be avoided. On one hand, it is currently
not possible to provide multiple inheritance since methods overloading is
essential for usable class combination. Now, the language is restricted
that inheritance is only allowed as long as no method overloading occurs.
This extension is considered as straightforward since the exact definition
which method should be called is already possible with full parent
specification by the caller. The current restriction is in many problems
annoying and is just a simplification since it is not a core problem which
is treated in this thesis project.

\paragraph{Matching as Higher Ordered Subtyping}
Currently the language uses the matching notion of f-bounded subtyping
which is a good but not the best option. As earlier mentioned matching
is also considered as higher ordered subtyping which brings additional
properties which are preferable. Although this would increase the
complexity, reflexivity and transitivity brings several advantages to
the programmer. Parametrised classes would gain expression power since
it would fit well in a subtyping environment. With this, the use would
be more flexible of those classes.

\paragraph{Modularisation}
Modularisation is also missing. With this only very monolithic programs
are possible where no separate compilation units are supported. For larger
programs this would increase compilation time and a flexible work between
developer teams is not supported. This makes \ooplss in its current state
useless for serious programs although the target platform is widely
used. Hand in hand supporting multiple files would be inevitable and
necessary for future developments.  Even simple modularisation would be
not very difficult a more sophisticated form is proposed where modules are
higher-order constructs and can be parametrised \cite{dreyer_type_2003}.

However, with the introduction of proper subclasses a simple form of
modularisation and code reuse is already provided. With this adding
existing code to classes is very simple and safe.

\paragraph{Top and Bottom Types}
The language design has some similarities to that of C++ which does
not have an implicitly superclass which Java and \cs have. With this
comes one drawback that it is not possible to write methods that accept
arbitrary objects if not a own superclass is specified and explicitly
extended. This decision is made because two class combinations are
possible and an implicit base class would force the programmer to one
of them at the very beginning of every class.

TODO... Weiter schreiben. Top / Bottom types

\paragraph{Pure Object Orientation}



\subsubsection{Future Implementation Work}

\paragraph{JDK Integration}

\paragraph{Subclassing with Dynamic Invokes}
Consolidate Subclassing and Subtyping with multiple dispatch and mytype (Dynamic invoke in Java 7).
Method overload with dynamic invokes

\paragraph{Syntax Inference}

\paragraph{Type Inference}




\section{Conclusion}
\label{ctr:conclusion}
%estimated pages: 2
