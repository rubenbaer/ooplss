\chapter{Language Specification}

\todo{Write an introduction explaining what this chapter is about}

\section{Design Principles}
The type system used for \ooplss is similar to that of \emph{TooL}
\cite{gawecki_tool:_1995}. Many important aspects differ from
\emph{TooL}. The used principles are these:

%\paragraph{Purely object-oriented}
%\ooplss is in contrast to its target platform Java a purely
%object-oriented language. Every program entity is represented by an
%object that can receive messages from other objects. There are no
%primitive data types that are not objects. Computing is performed only
%by message passing between objects. \todo{Integer?}

\paragraph{Class Based}
Creating new objects are an essential part in object-oriented
programming. \ooplss provides classes as templates for object
creation. The programmer can specify classes of objects and create
instance of them and not directly objects. Classes are considered as
first order constructs. Furthermore a program is a set of classes. Within
classes only methods and fields are allowed.

\paragraph{Static and Safe Type System}
To reduce the set of type specific runtime exceptions \ooplss is statically
and strongly typed. Every message sent to an object that is legal within
the type system can not create exceptions on runtime. Nonetheless runtime
exceptions can occur since the type system does not prove that every
statement is possible, e.g., sending a division by zero message to a
number object.  In this case, an appropriate exception will be thrown.

\paragraph{Nominal Type System}
There are two options how to determine the relation of subtyping
respectively matching between two types. On one hand there is the
structural analysis of the given types in the current context and on
the other there is the analysis of the type hierarchy and restricting
subtyping and subclassing. For the nominal subtyping special keywords
like \emph{extends} in Java or \emph{subtypeOf} in \ooplss is necessarily
and makes subtyping explicit between two object types which structural
subtyping does not.  Each concept has its assets and drawbacks but both
can be provided simultaneously \cite{malayeri_integrating_2008}. However,
\emph{TooL} and \emph{PolyTOIL} use structural subtyping, contrary to
Java which uses nominal subtyping. \ooplss has a nominal type system
for a modular type checking. Once the inheritance relations are checked,
it is easy to determine whether two types are in relation or not. Since
\ooplss is translated to Java, a similar system is used, i.e., a nominal
type system is implemented.

\paragraph{No Information Hiding}
Since nominal subtyping is used, information hiding has not that impact
compared to structural subtyping since all fields are automatically
available. This helps to keep the language small.

\paragraph{No Method Overloading}

\paragraph{Single Dispatch}

Further details in discussion!

\section{Syntax}
\subsection{Abstract Syntax}
The abstract syntax gives a short overview of \ooplss. This syntax is
not normalised and does not corresponds with the syntax used in the
implementation.

\begin{listing}
	\begin{tabular}[H]{lrll}
		PROG & \lra & CLASSES \\
		CLASSES & \lra & CLASS+ \\
		CLASS & \lra & `class' C$\langle$`['CLASSPPRMS`]'$\rangle$? combiners \\
		& & ~~~~`\{' VARDEF* METHODDEF* CONSTR* `\}' \\
		CLASSPRMS & \lra & CLASSPARAM $\langle$, CLASSPARAM $\rangle$* \\
		CLASSPARAM & \lra & TYPE \\
		 & | & TYPEVAR \match TYPE \\
		combiners & \lra & SUBTYPEOF? SUBCLASSOF? \\
		SUBTYPEOF & \lra & `subtypeOf' TYPE \\
		SUBCLASSOF & \lra & `subclassOf' TYPE $\langle$`,' TYPE $\rangle$* \\
		TYPE & \lra & TYPENAME \\
		& | & TYPEVAR \\
		TYPENAME & \lra & ID \\
		TYPEVAR & \lra & ID \\
		& | & \mytype \\
		VARDEF & \lra & `var' ID `:' TYPE `;' \\
		METHODDEF & \lra & `def' ID `(' PARAMS? `) :' TYPE `\{' EXPR* `\}'  \\
		CONSTR & \lra & `def \_\_construct (' PARAMS? `) \{' EXPR* `\}' \\
		EXPR & \lra & VARDEF \\
		& | & BLOCK \\
		& | & ID = EXPR `;' \\
		& | & VARDEF = EXPR `;' \\
		& | & `if (' EXPR `)' EXPR $\langle$ `else' EXPR $\rangle$?  \\
		& | & `while (' EXPR `)' EXPR \\
		& | & `new' TYPENAME `(' METHODPARAMS? `)' \\
		& | & EXPR `.' EXPR \\
		& | & EXPR `(' METHODPARAMS? `)' \\
		METHODPARAMS & \lra & EXPR $\langle$ `,' EXPR $\rangle$* \\
		BLOCK & \lra & `\{' EXPR* `\}' \\
		PARAMS & \lra & ID `:' TYPE $\langle$ `,' ID `:' TYPE $\rangle$ \\
		ID & \lra & $\langle$ a-z, A-Z, \_ $\rangle~\langle$ a-z, A-Z, 0-9, \_ $\rangle$*
	\end{tabular}
	\caption{Abstract syntax of \ooplss}
	\label{lst:abstractSyntax}
\end{listing}

\subsection{Names and Identifiers}
Names in \ooplss identify variables, methods, classes and types. The
definition of names can have different origins and depends on the current
context of consideration which is given by its scope.

\todo{Method overloading!}

\subsection{Scopes}
\ooplss uses lexical scoping to define the validity of expressions and 
variables which is similar to that of Java. Generally there exists a global
scope wherein the class definitions are. Within each class is a class-scope
that contains all fields, which includes the definition of superclasses and
supertypes. Local scopes exist within methods and can be nested arbitrary.
Nested local scopes can not shadow already bound variables, i.e., definitions
like that in Listing \ref{lst:illegalNesting} are not allowed.

\begin{lstlisting}[float,language=ooplss,caption=Variable definition in local scope,label=lst:illegalNesting]
class A {
	var x : B;

	def m(x : C) : Void {
		var x : D; // Illegal variable definition. Shadows local parameter.
	}

	def f() : Void {
		var x : A; 
		{
			var x : B; // Illegal variable definition. Shadows local variable.
		}
	}

	def g() : Void {
		{
			var x: A;
		}
		var x : B; // Legal variable definition since x : A is not 
							 // valid anymore.
	}
}
\end{lstlisting}
%Literals, Delimiters, 
\subsection{Whitespace and Comments}
Whitespace characters and comments separate single tokens in \ooplss. A
whitespace can either be a blank, a tab or a newline character.

Two kinds of comments are possible. The C-style multi-line comment which
starts with `/*' and ends with `*/'. Everything between these two delimiters
is ignored by the parser. One specialty to note is, that these kind of comments
can not be nested. 
The second kind is in the C++-style and is a single- line comment which starts 
with `//'. The character sequence between this token and the next newline
is ignored.


\section{Language Semantics}
%Classes build the foundation of \ooplss and contain one of the
%differences known in today's languages\todo{which one?}
%. 
Classes build the foundation of \ooplss with two kinds of combination mechanisms, 
\emph{inheritance} and \emph{extending}. The
first one creates a subclass and the second one a subtype of a given
type. For both cases a new keyword is introduced, \emph{subclassOf}
and \emph{subtypeOf}. The difference between them is the moment of
the self-type binding. In formal treatment a class is considered as a
unordered record \cite{simons_theory_2002-1}.

\subsection{Extension as Subtyping}
'Extension` is one sort of class combination in \ooplss. With extension, the concept
of nominal subtyping is implemented which is the same as \emph{extends} in Java.
Since \ooplss knows two sorts of combiners, a clearly distinguishable keyword is
introduced: \emph{subtypeOf}. Subtyping can be represented as a record combiner
where the recursive type binding is performed before the record combination.
However, the combiner does not only combine records, it also overrides 
\todo{Fields are not overridden are they?}
old fields which are shadowed by the new record and renames parent
fields \cite{simons_theory_2003-2}.

This record extension is semantically equivalent to that of Java. This
makes a straightforward implementation possible and easy to use for
current Java programmers. Listing \ref{lst:subtypeOf} shows an example
of subtyping in \ooplss.

\begin{lstlisting}[float,language=ooplss,caption=Subtyping in \ooplss,label=lst:subtypeOf]
class A {
	// Defines a method with parameter of type A.
	def m(p : A) : ReturnType { %\ldots) }
}

class B subtypeOf A {
	// Overrides the parent's method m(p) where A' <: A
	def m(p : A') : ReturnType { %\ldots) }
}
\end{lstlisting}

\todo{Base reference}

\subsubsection{Extension Class combiner}
\todo{Combination operator (No method overloading)}

\subsection{Inheritance as Subclassing}
Inheritance is the second class combiner in \ooplss. It is postulated
by Simons' Theory of Classification \cite{simons_theory_2004-2}.
This combination is not only a sort of class extension with code
reuse where the new class needs to follow subtyping rules and avoids
the problem of schizophrenic self-reference since the self-variable
binding is performed after the class combination and follows the notion
of inheritance in the classical sense. 
\todo{Reformulate, usually such sentences go "... not only A but also B..."}

\ooplss integrates this second
form of combination within the nominal subtyping model which is used as
well. This dual possibility is unseen in current programming languages.

To represent this kind of class combination the diagrams used in this documentary differ from classical
UML representation. The dashed lines show a subclass reference between two classes
like in \Cref{fig:subclassCombination}. The solid lines represent the same as in UML:
a subtype relation between two classes.

\begin{figure}
	\centering
	\includedot[scale=0.8]{dot/subclassCombination}
	\caption{Graphical representation of a inheritance class combination}
	\label{fig:subclassCombination}
\end{figure}

Semantically, a subclass is a break in the subtyping hierarchy, i.e., inheritance
combines classes without holding the subsumption property \ref{maybe ref... although it should be clear by now}
. This gives \ooplss
the possibility to have a class hierarchy whereas in Java complete new classes \todo{types?}
would be introduced. As illustrated in \Cref{fig:inheritHierarchy}. In Figure
\ref{fig:javaHierarchy} the types \emph{C'} and \emph{D'} are the combined types
defined in \ooplss. \todo{I don't understand this...}

\begin{figure}
	\centering
	\subfloat[\ooplss hierarchy]{
		\includedot[scale=0.8]{dot/ooplssHierarchy}
		\label{fig:ooplssHierarchy}
	}
	\subfloat[Java hierarchy]{
		\includedot[scale=0.8]{dot/javaHierarchy}
		\label{fig:javaHierarchy}
	}
	\caption{Class relation hierarchy in \ooplss and Java}
	\label{fig:inheritHierarchy}
\end{figure}

Following this semantics the translation of \ooplss-code to
other object-oriented languages can be done as stated in Listing
\ref{lst:subclassOf} and Listing \ref{lst:javaTrans}.

\begin{lstlisting}[float,language=ooplss,caption=Subclassing in \ooplss,label=lst:subclassOf]
class A {
	var a : A;

	def m(o : A) Void {
		m(a); // Recursive call
	}
}

class B subclassOf A {
	def m(o : A) Void {
		m(a);
		A.m(a);
	}
}
\end{lstlisting}

Listing \ref{lst:javaTrans} presents the code that was translated from Listing 
\ref{lst:subclassOf} to Java. It demonstrates the clear cut within 
the subtyping hierarchy since the whole content of class \A is modified
and copied to class \B.

\begin{lstlisting}[float,caption=Subclassing translated to Java,label=lst:javaTrans]
public class A {
	public A a;

	public void m(A o) {
		m(a); // Recursive call
	}
}

// Subclass of A
public class B {
	public A a;

	private void A$$m(A o) {
		m(a); // Recursion back to original method
	}

	// Override A.m()
	public void m(A o) {
		m(a); // Direct recursion
		A$$m(a); // Recursion call over class A
	}
}
\end{lstlisting}

\subsubsection{Inheritance Class combiner}
\todo{Combination operator}

\subsection{Introducing \mytype}
With subclassing another sort of class combination is introduced
\todo{Which is actually mentioned before already..?}
. By
observing the listings \ref{lst:subclassOf} and \ref{lst:javaTrans}
one may see something rather strange. While class \A has a recursive
object type it is not the case for class \B. Since these two classes are
completely decoupled but the type of the classes' type is not changed from
\A to \B the expression in Listing \ref{lst:breakSelf} can not be typed.

\begin{lstlisting}[float,language=ooplss,caption=Illegal method m(o : \A) : \emph{Void} in class \B,label=lst:breakSelf]
class A {
	def m(o : A) : A {
		return m(self); //Works fine in Java
	}
}

class B subclassOf A {
	def m(o : A) : A {
		return m(self); // Breaks in subclass!
	}
}
\end{lstlisting}

This code is illegal because \self is of type \B and subclassing does
not provide subsumption, in other words, \B $\nless$: \A. To overcome this problem,
a special type variable is introduced which is called \mytype.

This type variable is available in every class but has different meanings
depending on the class under consideration. It is the type correspondence
to the \self variable. Definition \ref{def:selfType} reflects this idea.

\begin{defn}[Self Type]
	\label{def:selfType}
	\self <: \mytype
\end{defn}

Listing \ref{lst:fixBreakSelf} fixes the code with the assumption of
definition \ref{def:selfType}.

\begin{lstlisting}[float,language=ooplss,caption=Type safe code with \mytype,label=lst:fixBreakSelf]
class A {
	def m(o : MyType) : MyType {
		return m(self); //Works well
	}
}

class B subclassOf A { three different examples were introduced where subtyping forces the programmer to write code that needs unsafe type casts and runtime checks.
	def m(o : MyType) : MyType {
		MyType A.m(self); // Works fine as well
	}
}
\end{lstlisting}

The demo in Listing \ref{lst:fixBreakSelf} shows how \mytype works 
in \ooplss.  Semantically this works because every occurrence of \mytype
is replaced with the new type of class \B. In other words, \mytype is
replaced after the classes are combined.

Listing \ref{lst:fixBreakSelf} shows the translation into the corresponding
Java code in \ref{lst:javaTransMyTypeSubclassing}. 

The recursive
method calls in method $m(o : MyType)$ makes clear that subclassing
provides a proper possibility for mutual recursion mentioned in
\Cref{sec:schizoReferences}. This behaviour is intended since this gives
programmers the possibility to take full control over the recursion
and correct program flow.

\begin{lstlisting}[float,caption=Subclassing with \mytype translated to Java,label=lst:javaTransMyTypeSubclassing]
public class A {
	public A m(A o) {
		m(this);
	}
}

public class B {
	private B A%\$\$)m(B o) {
		return m(this); // Recursion back to original method
	}

	// Override A.m()
	public B m(B o) {
		return A%\$\$)m(this); // Recursion call over class A
	}
}
\end{lstlisting}

\subsubsection{\mytype in Subtyping}
\label{ssec:mytypeInSubtype}
The \mytype was introduced to fix typing problems occurring with
inheritance. This raises the question whether a \mytype is suitable
with extension as well. This problem is illustrated in Listing
\ref{lst:myTypeSubtyping}: it is not sure what type the parameter
$o$ should have in class \B, type \B or type \A? 

\begin{lstlisting}[float,language=ooplss,caption=\mytype within subtyping contexts,label=lst:myTypeSubtyping]
class A {
	def m(o : MyType) : MyType {
		return m(self);
	}
}

class B subtypeOf A {
	def m(o : MyType) : MyType {
		return base.m(self);
	}
}
\end{lstlisting}

Let consider the consequences if $o : B$ in class \B. First of all this
method definition would necessarily require that \ooplss would support
method overloading which it does not. But there are other consequences which
are considerably more problematic like that $B.m$ would not be a subtype method of the one
provided from class \A. Knowing that $B.m$ is not a subtype if $A.m$ 
makes it impossible to create mutual recursion which is provided by inheritance
and only naive recursion would be possible within extension. This means
that if method $A.m$ is called there is no possibility to come back to object \B 
within this recursion as long as no dynamic dispatch is available since \B can 
not provide a own implementation of $m$ with $o : A$. However, even \B would
provide two implementations of $m$, one with $o : A$ and one with $o : B$ this
would lead to a contradiction if \B is used as a superclass. For this one may
consider \Cref{fig:hierarchy} and its corresponding code in Listing
\ref{lst:mixedHierarchy}. The problem is in line \ref{lst:mixedHierarchy1}. 
If this code segment would be combined in class \C, \self would now be of type
\C which is not a subtype of \A.

\begin{figure}[ht]
	\centering
	\includedot[scale=0.8]{dot/fixedSubclassingSubtyping}
	\caption{Subclassing and subtyping hierarchy}
	\label{fig:hierarchy}
\end{figure}

\begin{lstlisting}[float,language=ooplss,caption=Mixed extension and inheritance hierarchy,label=lst:mixedHierarchy]
class A {
	def m(o : MyType) : MyType {
		return m(self);
	}
}

class B subtypeOf A {
	def m(o : MyType) : MyType {
		return base.m(self);
	}

	def m(o : A) : MyType { 
		return o.m(self); // Not typeable in C!%\label{lst:mixedHierarchy1})
	}
}

class C subclassOf B {
	def m(o : MyType) : MyType {
		return B.m(self);
	}
}
\end{lstlisting}

For this the self compatibility is defined as follow:

\begin{defn}[Self is compatible with MyType]
	\label{def:selfCompatibility}
	For every class \A it is true that $self : MyType$ but not that $A <: MyType$
\end{defn}

\subsubsection{Binding Moment of \mytype}
To fit the behaviour described in \Cref{ssec:mytypeInSubtype} in
a uniform model of extension and inheritance the moment the MyType is bound
to a real type
needs to be considered more clearly. Listing
\ref{lst:bindingInMixedHierarchy} shows a mixed class hierarchy in
\ooplss. First of all \B extends \A. Here the \mytype in method $m$ is
not rebound in the subtype class, i.e., the \mytype binding in within
extension is as early as possible done. 
\todo{This doesn't make sense does it?}

This is fully the notion of
subtyping. However, in \B, the \mytype is not uniformly bound. Method $f$
has another bound of \mytype than $m$. This works perfectly fine
since $B <: A$. Going one step deeper in the hierarchy, inheritance is
performed. In class \C, every occurrence of \mytype is now rebound to
type \C. This works as well since the \self-type is defined as in definition
\ref{def:selfCompatibility}. Now, \C is also extended in \D where method
$g$ is overridden. Here again, since in extension the binding moment is
performed as early as possible, this fits well in to \ooplss' model of
class combination.

\begin{lstlisting}[float,language=ooplss,caption=Binding of \self and \mytype in a mixed context,label=lst:bindingInMixedHierarchy]
class A {
	def m(o : MyType) : MyType { // o : A
		return m(self); 
	}
}

class B subtypeOf A {
	def m(o : MyType) : MyType { // o : A
		return base.m(self);
	}

	def f(o : MyType) : MyType {  // o : B
		return o.f(self); 
	}
}

class C subclassOf B { // Rebinds every occurrence of MyType in hierarchy
	def m(o : MyType) : MyType { // o : C
		return B.m(self);
	}

	def g(o : MyType) : MyType { // o : C
		return g(self);
	}
}

class D subtypeOf C {
	def g(o : MyType) : MyType { // o : C
		return g(self);
	}
}
\end{lstlisting}

Although everything is now typeable, the question rises whether this 
code provides mutual
recursion as wanted?  \todo{Explanation of mutual recursion or ref}

Let's consider a method call of $m$ in \C. The
method call handle goes correctly to its superclass method $B.m$. Now
there the next problem may occur. How is the \base reference considered?
First of all, a \base reference does not make any sense here since
\C does not have a supertype except \object and \object usually doesn't provide
a method as wanted.

\subsubsection{Resolving Extension Ambiguity}
\label{sec:resolveAmbiguity}
Let's consider the extension and inheritance hierarchy in \Cref{fig:hierarchy}
again. It is clear that \C inherits \B. But what about the extension of \A 
with \B? As seen before, inheritance breaks the hierarchy and only
provides a possibility of class combination. This rises the question how the 
relation between \A and \B is considered when a subclass of \B exists. If
the self type in \A would be bound before the record combination to
\C, unsafe type constructs could be possible since a
method expecting type \A would not make any sense in class \C. From this
point of view the extension mechanism has two faces: in a pure
subtyping hierarchy it is subtyping and in a subclassing hierarchy the
extension mechanism is inheritance as well.

Knowing this fact generates the hierarchy in
\Cref{fig:fixedHierarchy} for the type \C. This makes it impossible
to use a explicit recursive self reference for classes since they are not
subclass compatible anymore, i.e., the \mytype is used wherever possible.
\todo{should be used?}

\begin{figure}[ht]
	\centering
	\includedot[scale=0.8]{dot/subclassingSubtyping}
	\caption{Subclassing hierarchy for class \C}
	\label{fig:fixedHierarchy}
\end{figure}
%
%\subsubsection{Method Overloading and Mutual Recursion}
%\subsubsection{}

\subsection{Type Relations}
\ooplss knows two different type relations. On one hand there exists
subtyping which is well known in typed object-oriented programming
languages denoted with <: respectively as a straight line in diagrams. On
the other hand there is a matching relation which is used to restrict type
parameters to a given protocol and is denoted with \match respectively
with a dashed line in diagrams. \Cref{fig:hierarchy} shows an example
of a type hierarchy in \ooplss.
%Only one subtype relation between type \A
%and \B exists. Between the other types exists a matching relation; \E
%\match \D \match \C \match \A and \E \match \B.

From this and \Cref{sec:resolveAmbiguity} follows directly that these
relations in \Cref{fig:fixedHierarchy} are true:
\begin{align}
B <: A \\
B <\!\!\#~A \label{alg:match} \\
C <\!\!\#~A \\
C <\!\!\#~B
\end{align}

%\ref{alg:match} makes problems

%\subsubsection{Matching is Compatible with Subtyping}

Since \ooplss uses a nominal type system and not a structural one,
matching does only apply on type within the same hierarchy as under
consideration even if other object types would match types of other
hierarchies.

\subsubsection{Matching Embeds Subtyping}
Now, after some considerations about matching, lets take a look at
proposition \ref{prop:matching}. Bruce is stated that `matching is
the same as subtyping in the absence of the MyType construct.' From
this proposition and definition \ref{def:matchingAsBound} the following
theorem is formulated that subtyping is embedded into matching which is
proven for \ooplss.

\begin{prop}[Matching as subtyping]
	\label{prop:matchinIsSubtyping}
	if $B <: A \rightarrow B$ \match $A$
\end{prop}

\begin{proof}
	For this one may recall how subtyping is to understand.\footnote{See
	definitions \ref{def:subtypeObject} and \ref{def:methodSubtyping}}.

	Let $B <: A$, $X := \mu self.\{m :
	B \times self \rightarrow C \} $ and $Y := \mu X.  $\todo{Formal Class combiners first needed}

%	\begin{enumerate}
%		\item From definition \ref{def:subtypeObject}
%		follows directly that $Y <: X$.
%
%		\item 
%	\end{enumerate}
\end{proof}

%\begin{mathpar}
%	\inferrule*[Right=foo]{A}{B}
%\end{mathpar}

\subsection{Class combiners Refined}
\todo{Give a full specification of class combiners with mytype and base rewriting}

\subsection{Class Parametrisation}
So far the introduction of a \mytype and proper inheritance gives the
advantage of proper code reuse within the type system and specialisation
of binary methods compared to other language. At a first glance all
this looks like not very useful since even generics like that from
Java does not fit into this model very well. Further more the matching
relation is not used by method parameters and does not appear yet\todo{where?}. As
seen in \Cref{ctr:makingSubclassingPractical} matching is used in object
parametrisation and does replaces generics respectively is the foundation
of Java's or \cs's generics. \todo{Ahja?}

These generics does only allow f-bounds with subtypes but not with
subclasses what is different in \ooplss because of the matching relation
between two subclasses.

\subsubsection{Translation by Mimic Templates}
Knowing that \ooplss class parametrisation is not compatible with that
from Java since Java knows only bounds on subtypes an other more open
solution is needed.  Using matching as bound provides information that
the code within a parametrised class is legal and can be executed on
objects which are within the bound. The type checker ensures that the
codes written in \ooplss are type safe and every method call can be
performed without any runtime errors since it is guaranteed that all
used fields are properly available on the passed objects.

From this thoughts the C++ templates are maybe a good choice for
representing parametric classes.

\begin{quotation}
`A class generated from a class template is a perfectly ordinary
class. Thus, use of a template does not imply any runtime mechanisms
beyond what is used for an equivalent ``hand-written'' class.' -- Bjarne
Stroustrup \cite{stroustrup_c++_2000}
\end{quotation}

Of course, C++ templates have a different semantics and are not equivalent
with this translation presented for \ooplss but the idea is similar to
create special classes similar to templates.

The next Listing \ref{lst:parametrisationOoplss} presents a container
class that is parametrised with a match-bound of \A. From \A exists an
extended class \B and a inherited class \C. Following the definition
of matching, both derived classes are not allowed as parameters
of the class \emph{Container} with the type parameter definition
of $T$ \match \A.  The use of thous classes is presented in Listing
\ref{lst:useParametrisationOoplss}. All of these assignments are typeable
and sound since all these classes provides the methods assumed by the
bound. However, Listing \ref{lst:parametrisationJava} shows how this code
is translated to Java and how the idea of templates is adopted. Like
in C++ the for every class a new inner class is created with special
names. These special classes are all sharing the same generic interface
\emph{Container}. That there is an interface needed, will be presented
in the next section. One may remarks that the Java interface of
\emph{Container} has dropped the f-bound. This is necessary since
subclassing would not fulfill the extension boundary in Java.

 To use this code in Java is straightforward translated in Listing
\ref{lst:useParametrisationJava}.

\begin{lstlisting}[float,language=ooplss,caption=Parametrisation in \ooplss,label=lst:parametrisationOoplss]
class Container[T %\match) A] {
	def m(t1 : T, t2 : T) : T {
		t.someAction(t2);
	}
}

class A {
	def someAction(x : MyType) : MyType {
		return self;
	}
}

class B subtypeOf A {
	def someAction(x : MyType) : MyType {
		return self;
	}
}

class C subclassOf A {
	def someAction(x : MyType) : MyType {
		return self;
	}
}
\end{lstlisting}

\begin{lstlisting}[float,language=ooplss,caption=Valid use of a match-bound container,label=lst:useParametrisationOoplss]
class Main {
	def run() : Void {
		var foo : Container[Foo] = new Container[Foo]();
		var bar : Container[Bar] = new Container[Bar]();
		var foobar : Container[FooBar] = new Container[FooBar]();
		foo.m(new Foo());
		bar.m(new Bar());
		foobar.m(new FooBar());
	}
}
\end{lstlisting}

\begin{lstlisting}[float,language=java,caption=Container class translated to Java,label=lst:parametrisationJava]
public interface Container<T> {
	public T m(t T);

	static public class Container$Foo$ implements Container<Foo> {
		public Foo m(t Foo) {
			t.someAction();
		}
	}

	static public class Container$Bar$ implements Container<Bar> {
		public Bar m(t Bar) {
			t.someAction();
		}
	}

	static public class Container$FooBar$ implements Container<FooBar> {
		public FooBar m(t FooBar) {
			t.someAction();
		}
	}
}
\end{lstlisting}

\begin{lstlisting}[float,language=java,caption=Use of parametised classes in Java,label=lst:useParametrisationJava]
public class Main {
	public void run() {
		Container<Foo> foo = new Container.Container$Foo$();
		Container<Bar> bar = new Container.Container$Bar$();
		Container<FooBar> foobar = new Container.Container$FooBar$();
		foo.m(new Foo());
		bar.m(new Bar());
		foobar.m(new FooBar());
	}
}
\end{lstlisting}

\subsubsection{Specialising Parametrised Classes}
As seen, parametrising classes with matching does now fit well in
the whole model. However, since parametrised classes can be too,
this is now shown that this is straightforward as well. For the
sake of simplicity only the translated Java code is presented since
fields that are not using parameters are translated like in normal
classes. Listing \ref{lst:extendingContainer} shows an extended version
of the \emph{Container} class.

\begin{lstlisting}[float,language=java,caption=Extending a container class translated to Java,label=lst:extendingContainer]
public interface SpecialContainer<X> extends Container<X> {
	public X f(X x);

	static public class SpecialContainer$Foo$ 
			extends Container$Foo$ 
			implements SpecialContainer<Foo> {
		public Foo m(Foo x) {
			return x;
		}
	}

	static public class SpecialContainer$Bar$ 
			extends Container$Bar$ 
			implements SpecialContainer<Bar> {
		public Bar m(Bar x) {
			return x;
		}
	}

	static public class SpecialContainer$FooBar$ 
			extends Container$FooBar$ 
			implements SpecialContainer<FooBar> {
		public FooBar m(FooBar x) {
			return x;
		}
	}
}
\end{lstlisting}

\subsubsection{Avoid Type Erasure}
The idea of generating extended class instead of using the runtime
generic support from Java is not new even the idea is a bit different
but has the same consequences. Robert Cartwright and Guy Steele proposed
an other kind of generics in Java as a concurrence to GJ from Odersky
and Wadler and is presented in \cite{cartwright_compatible_1998}. Their
project is called NextGen and is build up on Java 1.2. However, since
no generic types are used at runtime, type parameters are not erased
like GJ and Java 1.5 it does.

With this the language gains on runtime expressiveness since a
\emph{instanceof} operator can be introduced to perform checks on type
parameters which Java has not. Further the creation of new object would
also be possible as long as a class does provide a standard constructor.

As a drawback of creating all these classes is a more sophisticated 
bytecode analysis and engineering if a language would support a modular
code generation which \ooplss does not have so far. A further but not 
that relevant problem is the generated code overhead.

\subsubsection{Implicitly Parametrised Classes with \mytype}
At last in this section about parametrisation lets consider the \mytype
construct. As seen in \Cref{ctr:theoreticalBackground} the \self variable
can be bound with its real type by applying recursively the unbound type
operator. To grasp this notion in \ooplss, classes can be considered
as implicitly parametrised. Since both, subtyping and subclassing, is
available, the type parameter is extended in every subtype with one more.
Only this makes it possible to derive binary methods in subtypes
and subclasses as well. An explicit parametrised hypothetical use of
\mytype is presented in Listing \ref{lst:explicitMyType}.

\begin{lstlisting}[float,language=ooplss,caption=Explicit \mytype,label=lst:explicitMyType]
class A[MyType <# A] {
	def m(o : MyType) MyType {
		// Self is explicitly typed in the method.
		return self;
	}
}

class B[MyType <# B, MyType$A$ <# A] subtypeOf A[MyType$A$] {
	// MyType of class A is used in class B
	def m(o : MyType$A$) : MyType$A$ { %\ldots) }
	%\ldots)
}

class C[MyType <# C] subclassOf A[MyType] {
	%\ldots)
}

class D[MyType <# D] subclassOf B[MyType, MyType] {
	%\ldots)
}
\end{lstlisting}


%\subsubsection{No \#-Types in \ooplss}
%Research languages like \emph{LOOM}\cite{bruce_subtyping_1997},
%its successor \emph{polyToil}\cite{bruce_polytoil:_1995} or
%$\mathcal{MOOL}$\cite{bruce_foundations_2002} are all showing how
%matching can be integrated into object-oriented languages. All
%of them are using a structural type system. However, they also 
%introduced so called \#-types which. 

%\todo{Remove this section}

%Class definition
%\subsection{Constructors}
%\subsection{Evaluation Order}
\subsection{Built-in Types}


int, float, string, bool, char


Some build in types within the basic framework\ldots

