\part{Language Specification}
\chapter{Design Principles}
The type system used for \ooplss is similar to that of \emph{TooL}
\cite{gawecki_tool:_1995}. Many important aspects differ from
\emph{TooL}. The used principles are these:

\paragraph{Purely object-oriented}
\ooplss is in contrast to its target platform Java a purely
object-oriented language. Every program entity is represented by an
object that can receive messages from other objects. There are no
primitive data types that are not objects. Computing is performed only
by message passing between objects.

\paragraph{Class Based}
Creating new objects are an essential part in object-oriented
programming. \ooplss provides classes as templates for object
creation. The programmer can specify classes of objects and create
instance of them and not directly objects. Classes are considered as
first order constructs. Furthermore a program is a set of classes. Within
classes only methods and fields are allowed.

\paragraph{Static and Safe Type System}
To reduce the set of possible runtime exceptions \ooplss is statically
and strongly typed. Every message sent to an object that is legal within
the type system can not create exceptions on runtime. Nonetheless runtime
exceptions can occur since the type system does not prove that every
statement is possible, e.g., sending a division by zero message to a
number object.  In this case, an appropriate exception will be thrown.

\paragraph{Nominal Type System}
There are two options how to determine the relation of subtyping
respectively matching between two types. On one hand there is the structural
analysis of the given types in the current context and on the other there
is the analysis of the type hierarchy and restricting subtyping and
subclassing. Each concept has its assets and drawbacks but both can
be provided simultaneously \cite{malayeri_integrating_2008}. However,
\emph{TooL} and \emph{PolyTOIL} use structural subtyping, contrary to
Java which uses nominal subtyping. \ooplss has a nominal type system
for a modular type checking. Once the inheritance relations are checked,
it is easy to determine whether two types are in relation or not. Since
\ooplss is translated to Java, a similar system is used, i.e., a nominal
type system is implemented.

\paragraph{No Information Hiding}
Since nominal subtyping is used, information hiding has not that impact
compared to structural subtyping since all fields are automatically
available. This helps to keep the language small.

\chapter{Syntax}
\section{Abstract Syntax}
The abstract syntax gives a short overview of \ooplss. This syntax is
not normalised and does not corresponds with the syntax used in the
implementation.\\

\begin{listing}
	\begin{tabular}[H]{lrll}
		PROG & \lra & CLASSES \\
		CLASSES & \lra & CLASS+ \\
		CLASS & \lra & `class' C$\langle$`['CLASSPPRMS`]'$\rangle$? COMBINATORS \\
		& & ~~~~`\{' VARDEF* METHODDEF* CONSTRUCTOR* `\}' \\
		CLASSPRMS & \lra & CLASSPARAM $\langle$, CLASSPARAM $\rangle$* \\
		CLASSPARAM & \lra & TYPE \\
		 & | & TYPEVAR \match TYPE \\
		COMBINATORS & \lra & SUBTYPEOF? SUBCLASSOF? \\
		SUBTYPEOF & \lra & `subtypeOf' TYPE \\
		SUBCLASSOF & \lra & `subclassOf' TYPE $\langle$`,' TYPE $\rangle$* \\
		TYPE & \lra & TYPENAME \\
		& | & TYPEVAR \\
		TYPENAME & \lra & ID \\
		TYPEVAR & \lra & ID \\
		& | & \mytype \\
		VARDEF & \lra & `var' ID `:' TYPE `;' \\
		METHODDEF & \lra & `def' ID `(' PARAMS? `) :' TYPE `\{' EXPR* `\}'  \\
		CONSTRUCTOR & \lra & `def \_\_construct (' PARAMS? `) \{' EXPR* `\}' \\
		EXPR & \lra & VARDEF \\
		& | & BLOCK \\
		& | & ID = EXPR `;' \\
		& | & VARDEF = EXPR `;' \\
		& | & `if (' EXPR `)' EXPR $\langle$ `else' EXPR $\rangle$?  \\
		& | & `while (' EXPR `)' EXPR \\
		& | & `for (' EXPR `;' EXPR `;' EXPR `)' EXPR \\
		& | & EXPR `.' EXPR \\
		& | & EXPR `(' METHODPARAMS? `)' \\
		METHODPARAMS & \lra & EXPR $\langle$ `,' EXPR $\rangle$* \\
		BLOCK & \lra & `\{' EXPR* `\}' \\
		PARAMS & \lra & ID `:' TYPE $\langle$ `,' ID `:' TYPE $\rangle$ \\
		ID & \lra & $\langle$ a-z, A-Z, \_ $\rangle~\langle$ a-z, A-Z, 0-9, \_ $\rangle$* \\
	\end{tabular}
	\caption{Abstract syntax of \ooplss}
	\label{lst:abstractSyntax}
\end{listing}

\section{Names and Identifiers}
Names in \ooplss identify variables, methods, classes and types. The
definition of names can have different origins and depends on the current
context of consideration which is given by its scope.

\todo{Method overloading!}

\section{Scopes}
\ooplss uses lexical scoping to define the validity of expressions and 
variables which is similar to that of Java. Generally there exists a global
scope wherein the class definitions are. Within each class is a class-scope
that contains all fields, which includes the definition of superclasses and
supertypes. Local scopes exist within methods and can be nested arbitrary.
Nested local scopes can not shadow already bound variables, i.e., definitions
like that in listing \ref{lst:illegalNesting} are not allowed.

\begin{lstlisting}[float,language=ooplss,caption=Variable definition in local scope,label=lst:illegalNesting]
class A {
	var x : B;

	def m(x : C) : Void {
		var x : D; // Illegal variable definition. Shadows local parameter.
	}

	def f() : Void {
		var x : A; 
		{
			var x : B; // Illegal variable definition. Shadows local variable.
		}
	}

	def g() : Void {
		{
			var x: A;
		}
		var x : B; // Legal variable definition since x : A is not 
							 // valid anymore.
	}
}
\end{lstlisting}
%Literals, Delimiters, 
\section{Whitespace and Comments}
Whitespace characters and comments separate single tokens in \ooplss. A
whitespace can either be a blank, a tab or a newline character.

Two kinds of comments are possible. The C-style multi-line comments which
starts with `/*' and ends with `*/'. Everything between these two delimiters
is ignored by the parser. One specialty to note is, that these kind of comment
can not be nested. The second kind comes in the C++-style and is a single-
line comment which starts with `//'. The character sequence behind this token
until to the next newline is ignored.

%\section{Declarations and Definitions}
%\subsection{Type Parameters}

\chapter{Language Semantics}
Classes build the foundation of \ooplss and contain one of the
differences known in today's languages\todo{which one?}
. \ooplss provides two possible
mechanisms for \emph{inheritance} respectively \emph{extending}. The
first one creates a subclass and the second a subtype of a given
one. For both cases a new keyword is introduced, \emph{subclassOf}
and \emph{subtypeOf}. The difference between both is the moment of
the self-type binding. For formal treatment a class is considered as a
unordered record \cite{simons_theory_2002-1}.

\section{Extension as Subtyping}
Extension is one sort of class combination in \ooplss. With extension the concept
of nominal subtyping is implemented which is the same as \emph{extends} in Java.
Since \ooplss knows two sorts of combinators, a clear distinguishable keyword is
introduced: \emph{subtypeOf}. Subtyping can be represented as a record combinator
where the recursive type binding is performed before the records are combined.
However, the combinator does not only combine records, it also overrides old
fields which are shadowed by the new record and renames parent
fields \cite{simons_theory_2003-2}.

This record extension is semantically equivalent with that of Java. This
makes a straightforward implementation possible and easy to use for
current Java programmers. Listing \ref{lst:subtypeOf} gives a example
of subtyping in \ooplss.

\begin{lstlisting}[float,language=ooplss,caption=Subtyping in \ooplss,label=lst:subtypeOf]
class A {
	// Defines a method with parameter of type A.
	def m(p : A) : ReturnType { %\ldots) }
}

class B subtypeOf A {
	// Overrides the parent's method m(p) where A' <: A
	def m(p : A') : ReturnType { %\ldots) }
}
\end{lstlisting}

\subsection{Extension Class Combinator}
\todo{Combination operator (No method overloading)}

%The extension mechanism is the same as provided by Java. Instead of
%the \emph{extends} keyword a new is introduced: \emph{subtypeOf} which
%makes a clear distinction to subclass building. Since in subtyping in a
%class the \mytype is first bound and afterwards the classes are combined,
%overriding a method must be specified with parameters conforming to the
%subtype relation. In other words the \mytype construct is here useless
%since \mytype would have different meaning in the different classes. Listing
%\ref{lst:subtypeOf} demonstrates this behaviour.
%
%For a seamless integration into Java and other target systems without multiple
%inheritance, the class can only build one subtype at once.
%
%\begin{lstlisting}[float,language=ooplss,caption=Subtyping in \ooplss,label="lst:subtypeOf"]
%class A {
%	// Defines a method with parameter of type A.
%	def m(p : MyType) : RType {
%		%\ldots)
%	}
%}
%
%class B subtypeOf A {
%	// Provides a new method with parameter of type B.
%	// which is not in a subtype of the parent method m(o).
%	def m(p : MyType) : RType {
%		%\ldots)
%	}
%
%	// Overrides the method m of class A.
%	def m(p : A) : RType {
%		%\ldots)
%	}
%}
%\end{lstlisting}

\section{Inheritance as Subclassing}
Inheritance is the second possibility of class combination in \ooplss. It
is postulated by Simons' Theory of Classification \cite{simons_theory_2004-2}.
This combination is not only a sort of class extension with code reuse where
the new class needs to follow subtyping rules and avoids the problem of
schizophrenic self-reference since the self-variable binding is performed after
the class combination and follows the notion of inheritance in the
classical sense. \ooplss integrates this second form of combination within
the nominal subtyping model which is used as well. This dual possibility is
unseen in current programming languages.

Semantically a subclass is a break in the subtyping hierarchy, i.e., inheritance
combines classes without holding the subsumption property. This gives \ooplss
the possibility to have a class hierarchy where in Java complete new classes
would be introduced. This is illustrated in \cref{fig:inheritHierarchy}. In figure
\ref{fig:javaHierarchy} the types \emph{C'} and \emph{D'} is the combined type
defined in \ooplss.

\begin{figure}[h]
	\centering
	\subfigure[\ooplss hierarchy]{
		\digraph[scale=0.8]{OoplssHierarchy}{
			rankdir=BT;
			margin=0;
			A[fontname=LMRoman10];
			B[fontname=LMRoman10];
			C[fontname=LMRoman10];
			D[fontname=LMRoman10];
			B -> A;
			C -> A [style=dashed];
			D -> C [style=dashed];
			D -> B [style=dashed];
			} \label{fig:ooplssHierarchy}
			}
		\subfigure[Java hierarchy]{
		\digraph[scale=0.8]{JavaHierarchy}{
			rankdir=BT;
			margin=0;
			A[fontname=LMRoman10];
			B[fontname=LMRoman10];
			C[fontname=LMRoman10];
			D[fontname=LMRoman10];
			B -> A;
			C[label="C'"];
			D[label="D'"];
			} \label{fig:javaHierarchy}
			}
	\caption{Class relation hierarchy in \ooplss and Java}
	\label{fig:inheritHierarchy}
\end{figure}

\todo{Add legend to explain the arrows}

Following this semantics the translation of \ooplss-code to
other object-oriented languages can be done as stated in listing
\ref{lst:subclassOf} and listing \ref{lst:javaTrans}.

\begin{lstlisting}[float,language=ooplss,caption=Subclassing in \ooplss,label=lst:subclassOf]
class A {
	var a : A;

	def m(o : A) Void {
		%\ldots)
		m(a); // Recursive call
		%\ldots)
	}
}

class B subclassOf A {
	def m(o : A) Void {
		%\ldots)
		m(a);
		A.m(a);
		%\ldots)
	}
}
\end{lstlisting}

The following listing \ref{lst:javaTrans} presents the to Java translated
code of listing \ref{lst:subclassOf}. It demonstrates the clear cut within 
the subtyping hierarchy since the whole content of class \emph{A} is modified
and copied to class \emph{B}.

\begin{lstlisting}[float,caption=Subtyping translated in Java,label=lst:javaTrans]
public class A {
	public A a;

	public void m(A o) {
		%\ldots)
		m(a); // Recursive call
		%\ldots)
	}
}

// Subclass of A
public class B {
	public A a;

	private void A$$m(A o) {
		%\ldots)
		m(a); // Recursion back to original method
		%\ldots)
	}

	// Override A.m()
	public void m(A o) {
		%\ldots)
		m(a); // Direct recursion
		A$$m(a); // Recursion call over class A
		%\ldots)
	}
}
\end{lstlisting}

\subsection{Inheritance Class Combinator}
\todo{Combination operator}

\section{Introducing \mytype}
With subclassing an other sort of class combination is introduced. By
observing the listings \todo{reference} one may see something rather strange. While
class \emph{A} has a recursive object type it is not the case for
class \emph{B}. Since these two classes are completely decoupled but
the type of the classes' type is not changed from \emph{A} to \emph{B}
the expression in listing \ref{lst:breakSelf} can not be typed.

\begin{lstlisting}[float,language=ooplss,caption=Illegal method m(o : \emph{A}) : \emph{Void} in class \emph{B},label=lst:breakSelf]
def m(o : A) Void {
	%\ldots)
	m(self); // Breaks in subclass!
	%\ldots)
}
\end{lstlisting}

This code is illegal because \emph{self} is of type \emph{B} and
subclassing does not provide subsumption, i.e., \emph{B} $\nless$:
\emph{A}. To overcome this problem, a special type variable is
introduced which is called \mytype. Wherever a \mytype is used it will
get bound with the type that is generated.

\begin{figure}[h]
	\centering
	\digraph[scale=0.8]{FixedSubclassingSubtyping}{
		rankdir=BT;
		margin=0;
		A[fontname=LMRoman10];
		B[fontname=LMRoman10];
		C[fontname=LMRoman10];
		D[fontname=LMRoman10];
		E[fontname=LMRoman10];
		B -> A;
		C -> A [style=dashed];
		D -> C [style=dashed];
		E -> D [style=dashed];
		E -> B [style=dashed];
		}
	\caption{Subclassing and subtyping hierarchy}
	\label{fig:hierarchy}
\end{figure}

\section{Resolving Extension Ambiguity}
\label{sec:resolveAmbiguity}
Lets consider the extension and inheritance hierarchy in \cref{fig:hierarchy}
again. A special remark is given in the left side of this graph. It is clear
that \emph{C} inherits \emph{B}. But what about the extension of \emph{A} 
with \emph{B}? As seen before, inheritance breaks the hierarchy and does only
provide a possibility of class combination. This rises the question how the 
relation between \emph{A} and \emph{B} is considered. If the self type in 
\emph{A} would be bound before the record combination to \emph{E} would be
performed unsafe type constructs could be possible since a method expecting 
type \emph{A} would not make any sense in class \emph{E}. From this point of 
consideration the extension mechanism has two faces. In a pure subtyping 
hierarchy it is subtyping and in a subclassing hierarchy the extension
mechanism is inheritance as well.

Knowing this fact generates the following hierarchy in \cref{fig:fixedHierarchy}
for the type \emph{E}. This fact makes it impossible to use a explicit recursive
self reference for classes since they are not subclass compatible anymore, i.e.,
the \mytype is used wherever possible. 

\begin{figure}[h]
	\centering
	\digraph[scale=0.8]{SubclassingSubtyping}{
		rankdir=BT;
		margin=0;
		A[fontname=LMRoman10];
		B[fontname=LMRoman10];
		C[fontname=LMRoman10];
		D[fontname=LMRoman10];
		E[fontname=LMRoman10];
		B -> A [style=dashed];
		C -> A [style=dashed];
		D -> C [style=dashed];
		E -> D [style=dashed];
		E -> B [style=dashed];
		}
	\caption{Subclassing hierarchy for class \emph{E}}
	\label{fig:fixedHierarchy}
\end{figure}

\section{Type Relations}
\ooplss knows two different type relations. On one hand there exists
subtyping which is well known in typed object-oriented programming
languages denoted with <: respectively as a straight line in diagrams. On
the other hand there is a matching relation which is used to restrict type
parameters to a given protocol and is denoted with \match respectively
with a dashed line in diagrams. \Cref{fig:hierarchy} shows an example
of a type hierarchy in \ooplss.
%Only one subtype relation between type \emph{A}
%and \emph{B} exists. Between the other types exists a matching relation; \emph{E}
%\match \emph{D} \match \emph{C} \match \emph{A} and \emph{E} \match \emph{B}.

From this and \cref{sec:resolveAmbiguity} follows directly that these
relations in \cref{fig:fixedHierarchy} are true:
\begin{align}
B <: A \\
B \nless\!\!\#~A \label{alg:match} \\
E <\!\!\#~A \\
E <\!\!\#~B \\
\end{align}

\ref{alg:match} makes problems

%\subsection{Matching is Compatible with Subtyping}

Now, after some considerations about matching, lets take a look at
proposition \ref{prop:matching}. Bruce is stated that `matching is the same as
subtyping in the absence of the MyType construct.'

\begin{thm}[Matching as subtyping]
	\label{thm:matchinIsSubtyping}
	if $B <: A \rightarrow B$ \match $A$
\end{thm}

\begin{proof}
	For this one may recall how subtyping is to understand.\footnote{See
	definitions \ref{def:subtypeObject} - \ref{def:methodSubtyping}}.

	Let $B <: A$, $X := \mu MyType.\{m :
	B \times MyType \rightarrow C \} $ and $Y := \mu X.  $\todo{Class combinators}

	\begin{enumerate}
%		\item From definition \ref{def:subtypeObject}
%		follows directly that $Y <: X$.

		\item 
	\end{enumerate}
\end{proof}

Since \ooplss uses a nominal type system and not a structural one,
matching does only apply on type within the same hierarchy as under
consideration even if other object types would match types of other
hierarchies.

\section{Class Parametrisation}
So far the introduction of a \mytype and proper inheritance gives not a
enormous advantage compared to other languages only that some work can
be reduced by reusing existing code in new classes. At a first glance
all this looks like not very useful since even generics like that from
Java does not fit into this model very well. Further more the matching
relation is not used by method parameters and does not appear yet. As
seen in \cref{ctr:makingSubclassingPractical} matching is used in object
parametrisation and does replaces generics respectively is the foundation
of Java's or \cs's generics.

These generics does only allow f-bounds with subtypes but not with
subclasses what is different in \ooplss because of the matching relation
between two subclasses.

\subsection{No \#-Types in \ooplss}
\cite{bruce_foundations_2002}

%\section{Class Combinators}
%Class definition
%\section{Constructors}
%\section{Linearisation}
\section{Basic Types}
Some build in types within the basic framework\ldots

%\chapter{Syntax and Type Inference}
% estimated pages:	5
