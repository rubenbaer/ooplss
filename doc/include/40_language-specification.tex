\part{Language Specification}
\chapter{Design Principles}
The type system used for \ooplss is similar to that of \emph{TooL}
\cite{gawecki_tool:_1995}. Anyway, many important aspects differ from
\emph{Tool}. The used principles are these:

\paragraph{Purely object-oriented}
\ooplss is in contrast to its target platform Java a purely
object-oriented language. Every program entity is represented by an
object that can receive messages from other objects. There exists no
primitive data types which are not objects. Computing is performed only
by message passing between objects.

\paragraph{Class Based}
Creating new objects are an essential part in object-oriented
programming. In \ooplss classes are

\paragraph{Static Type System}
To reduce the set of possible runtime exceptions \ooplss is statically
and strongly typed. Every message sent to an object is legal is possible
and can not create exceptions on runtime. Nonetheless runtime exceptions
can occur since the type system does not prove that every statement is
possible, e.g., sending a division by zero message to a number object,
an appropriate exception will be thrown.

\paragraph{Safe Type System}

\paragraph{Nominal Type System}
There are two options how to determine the relation of subtyping
respectively matching between two types. On one hand is structural
analysis of the given types in the current context and on the other
is the analysis of the type hierarchy and restricting subtyping and
subclassing. Each concept has its assets and drawbacks but both can
be provided simultaneously \cite{malayeri_integrating_2008}. However,
\emph{TooL} and \emph{PolyTOIL} use structural subtyping compared to
Java which uses nominal subtyping. \ooplss has a nominal type system
for a modular type checking. Once the inheritance relations are checked,
it is easy to determine whether two types are in relation or not. Since
\ooplss is translated to Java a similar system is used, i.e., a nominal
type system is implemented.

\paragraph{No Information Hiding}
Since nominal subtyping is used, information hiding has not that impact
compared to structural subtyping since all fields are automatically
available. This helps to keep the language as small.
% estimated pages: 2
% summary of language design

\chapter{Syntax}
\ooplss's syntax is kept simple and consistent.

\section{Abstract Syntax}
The abstract syntax gives a short overview of \ooplss. This syntax is
not normalised and does not corresponds with the syntax used in the
implementation.

% estimated pages: 10
\begin{listing}
	\begin{tabular}[H]{llrll}
		\emph{Class}					& C	& $\longrightarrow$ 		& A[B] Subclass Of D[T], E[U] Subtype Of F[V] \{T a; T M;\} \\
		\emph{Types}					& T & $\longrightarrow$ 		& A \\
													&   & 									 | & A \match B[A] \\
		\emph{Method}					& M	& $\longrightarrow$ 		& T m[S](U a, V b) \{e;\} \\
		\emph{Constructor}		& K	& $\longrightarrow$ 		& c(U a, V b) \{A(a); e;\} \\
		\emph{Expression}			& e & $\longrightarrow$ 		& x; \\
													&   & 									 | & x = y; \\
													&   & 									 | & e.f; \\
													&   & 									 | & e.m(p); \\
													&   & 									 | & new C(p); \\
	\end{tabular}
\caption{Abstract syntax of \ooplss}
\label{lst:abstractSyntax}
\end{listing}

\section{Identifiers}

\section{Literals}

\section{Delimiters}

\section{Whitespace and Comments}


\chapter{Types}
\begin{listing}
	\begin{tabular}[H]{lrl}
		Types & \lra & Type \{, Type\}* \\
		Type & \lra & FunctionArgumentTypes \ra Type\\
				& | & SimpleType \\
		FunctionArgumentTypes & \lra & `(' SimpleType \{, SimpleType \} `)' \ra SimpleType \\
		SimpleType & \lra & SimpleType TypeArguments \\
								& | & TypeIdentifier \\
								& | & BoundedType \\
								& | & \mytype \\
		TypeArguments &\lra & `[' SimpleType \{, SimpleType \}* `]' \\
		BoundedType & \lra & SimpleType `\match' SimpleType \\
	\end{tabular}
\end{listing}

% estimated pages: 14

\section{Basic Types}
\section{Type Relations}

\chapter{Names and Scopes}
Names identify variables, methods, classes and types. These 
% estimated pages: 2

\section{Declarations and Definitions}
\subsection{Variable Declaration and Definition}
\subsection{Type Parameters}

\chapter{Classes}
% estimated pages: 6
\section{Subtypes}
\section{Subclasses}

%Class definition
\section{Constructors}
\section{Linearisation}

\chapter{Expression}

\chapter{Syntax and Type Inference}
% estimated pages:	5
