\part{Language Specification}
\chapter{Design Principles}
The type system used for \ooplss is similar to that of \emph{TooL}
\cite{gawecki_tool:_1995}. Anyway, many important aspects differ from
\emph{Tool}. The used principles are these:

\paragraph{Purely object-oriented}
\ooplss is in contrast to its target platform Java a purely
object-oriented language. Every program entity is represented by an
object that can receive messages from other objects. There exists no
primitive data types which are not objects. Computing is performed only
by message passing between objects.

\paragraph{Class Based}
Creating new objects are an essential part in object-oriented
programming. In \ooplss classes are the first order constructs. A program is
a set of classes. Within these classes only methods and fields allowed.

\paragraph{Static and Safe Type System}
To reduce the set of possible runtime exceptions \ooplss is statically
and strongly typed. Every message sent to an object is legal is possible
and can not create exceptions on runtime. Nonetheless runtime exceptions
can occur since the type system does not prove that every statement is
possible, e.g., sending a division by zero message to a number object,
an appropriate exception will be thrown.

\paragraph{Nominal Type System}
There are two options how to determine the relation of subtyping
respectively matching between two types. On one hand is structural
analysis of the given types in the current context and on the other
is the analysis of the type hierarchy and restricting subtyping and
subclassing. Each concept has its assets and drawbacks but both can
be provided simultaneously \cite{malayeri_integrating_2008}. However,
\emph{TooL} and \emph{PolyTOIL} use structural subtyping compared to
Java which uses nominal subtyping. \ooplss has a nominal type system
for a modular type checking. Once the inheritance relations are checked,
it is easy to determine whether two types are in relation or not. Since
\ooplss is translated to Java a similar system is used, i.e., a nominal
type system is implemented.

\paragraph{No Information Hiding}
Since nominal subtyping is used, information hiding has not that impact
compared to structural subtyping since all fields are automatically
available. This helps to keep the language as small.
% estimated pages: 2
% summary of language design

\chapter{Syntax}

\section{Abstract Syntax}
The abstract syntax gives a short overview of \ooplss. This syntax is
not normalised and does not corresponds with the syntax used in the
implementation.

% estimated pages: 10
%\begin{listing}
%	\begin{tabular}[H]{llrll}
%		\emph{Class}					& C	& $\longrightarrow$ 		& A[B] Subclass Of D[T], E[U] Subtype Of F[V] \{T a; T M;\} \\
%		\emph{Types}					& T & $\longrightarrow$ 		& A \\
%													&   & 									 | & A \match B[A] \\
%		\emph{Method}					& M	& $\longrightarrow$ 		& T m[S](U a, V b) \{e;\} \\
%		\emph{Constructor}		& K	& $\longrightarrow$ 		& c(U a, V b) \{A(a); e;\} \\
%		\emph{Expression}			& e & $\longrightarrow$ 		& x; \\
%													&   & 									 | & x = y; \\
%													&   & 									 | & e.f; \\
%													&   & 									 | & e.m(p); \\
%													&   & 									 | & new C(p); \\
%	\end{tabular}
%\caption{Abstract syntax of \ooplss}
%\label{lst:abstractSyntax}
%\end{listing}

\section{Names and Identifiers}
Names in \ooplss identify variables, methods, classes and types. The definition of names can have different origins and depends on the current context of consideration. Currently 

\section{Scopes}
Names identify variables, methods, classes and types. 

\section{Literals}

\section{Delimiters}

\section{Whitespace and Comments}
% estimated pages: 2

\section{Declarations and Definitions}
\subsection{Variable Declaration and Definition}
\subsection{Type Parameters}

\chapter{Classes}
Classes build the foundation of \ooplss and contain one of the differences
known in today's languages. \ooplss provides to possible mechanisms for
\emph{inheritance} respectively \emph{extending}. The first one creates
a subclass and the second a subtype of a given one. For both cases a new
keyword is introduced. The difference between both is the moment of the
self-type binding.

\section{Extension as Subtyping}
The extension mechanism is the same as provided by Java. Instead of
the \emph{extends} keyword a new is introduced: \emph{subtypeOf} which
makes a clear distinction to subclass building. Since in subtyping in a
class the \mytype is first bound and afterwards the classes are combined,
overriding a method must be specified with parameters conforming to the
subtype relation. In other words the \mytype construct is here useless
since \mytype would have different meaning in the different classes. Listing
\ref{lst:subtypeOf} demonstrates this behaviour.

For a seamless integration into Java and other target systems without multiple
inheritance, the class can only build one subtype at once.

\begin{lstlisting}[language=ooplss,caption=Subtyping in \ooplss,label="lst:subtypeOf"]
class A {
	// Defines a method with parameter of type A.
	def m(p : MyType) : RType {
		%\ldots)
	}
}

class B subtypeOf A {
	// Provides a new method with parameter of type B.
	def m(p : MyType) : RType {
		%\ldots)
	}

	// Overrides the method m of class A.
	def m(p : A) : RType {
		%\ldots)
	}
}
\end{lstlisting}

\section{Inheritance as Subclassing}
Proper inheritance is the second class combination possibility in \ooplss. 

\section{Semantics}
\begin{figure}
	\centering
	\digraph[scale=0.8]{MultipleInheritance}{
		rankdir=BT;
		B -> A;
		C -> A [style=dashed];
		D -> C [style=dashed];
		E -> D [style=dashed];
		E -> B [style=dashed];
		}
	\caption{Multiple inheritance hierarchy}
	\label{fig:multiInherit}
\end{figure}

\section{Parametrisation}
%Class definition
\section{Constructors}
\section{Linearisation}



\chapter{Expression}

\chapter{Types}
\ooplss knowns three sorts of types. First of all are

\begin{listing}
	\begin{tabular}[H]{lrl}
		Types & \lra & Type \{, Type\}* \\
		Type & \lra & FunctionArgumentTypes \ra Type\\
				& | & SimpleType \\
		FunctionArgumentTypes & \lra & `(' SimpleType \{, SimpleType \} `)' \ra SimpleType \\
		SimpleType & \lra & SimpleType TypeArguments \\
								& | & TypeIdentifier \\
								& | & BoundedType \\
								& | & \mytype \\
		TypeArguments &\lra & `[' SimpleType \{, SimpleType \}* `]' \\
		BoundedType & \lra & SimpleType `\match' SimpleType \\
	\end{tabular}
\end{listing}

% estimated pages: 14
\section{Type Relations}
\section{Basic Types}

%\chapter{Syntax and Type Inference}
% estimated pages:	5
