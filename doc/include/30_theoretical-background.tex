\chapter{Theoretical Background}
\label{ctr:theoreticalBackground}
In modern object-oriented programming languages \emph{subtyping} is the
fundamental and only concept for class combination. Often but imprecise it
is called \emph{subclassing}  as well. However, this chapter investigates
the differences between the two concepts of subtyping and subclassing. Even
subtyping has its own advantages it is also limited in expressiveness if
binary methods are used and these appear in a programmer's daily work.

This parts introduces these concepts mentioned above and where subtyping
and where subclassing is wanted and explains where the difference are.
Subtyping is used for polymorphism in object-oriented languages,
whereas subclassing is not. But to make subclassing practical at work
an additional relation needs to be introduced: \emph{matching}. Matching
raises the language to function-bounded typing with recursive self types.

\section{Subtyping and Subclassing}
\label{chap:subtypingVsSubclassing}
In this chapter we want you to get familiar with the terms subtyping
and subclassing and their differences. Both concepts exist in some of
the widely known object oriented programming languages like Java, Eiffel
or C++, but are usually mixed up. Either subclassing is supported with
improper subtyping or otherwise.

\subsection{Subtyping}
Subtyping is a binary relation, denoted with `<:', which defines
a substitution relation between two types and is one style of type
polymorphism. Assuming that a type $A$ is a subtype of $B$, then subtyping
ensures that $A$ has compatible methods and data fields, together simply
called fields, to its \emph{supertype} $B$. This implies that wherever
type $B$ is expected type $A$ can be used.

To ensure this type compatibility between $A$ and $B$ subtyping has the
following properties:

\begin{defn}[Subtype reflexivity]
	\label{def:subtypeReflexivity}
	\begin{mathpar}
		\inferrule*{\\}{A <: A}
	\end{mathpar}
\end{defn}
\begin{defn}[Subtype transitivity]
	\label{def:subtypeTransitivity}
	\begin{mathpar}
		\inferrule*{A <: B\\B <: C}{A <: C}
	\end{mathpar}
\end{defn}

Type safe subtyping is defined for objects and fields. Subtyping for
objects is quite easy. If $A$ <: $B$ then $A$ needs at least as many
fields as $B$ which are in subtype relation. Further $A$ can contain
other fields which does not have any correspondence in $B$. Since objects
are often considered as records -- which are ordered -- in subtyping
permutations of those are defined as equal.
\begin{defn}[Object subtyping]
	\label{def:subtypeObject}
	$\{l_b : Y_b\} <: \{l_a : X_a\}$ if $A$ contains $a \in
	\mathbb{N}$ fields, $B$ contains $b \geq a$ fields and for each
	$i$ it is true that $Y_i <: x_i$.
\end{defn}

The relation for fields differs for methods and object variables.

Variables needs to be type invariant in a subtyping context since
subtyping is not symmetric, i.e. $A$ <: $B$ does not imply $B$ <: $A$
if $A \neq B$.

Subtyping method types, denoted as $A \rightarrow B$ for a function with
domain $A$ and codomain $B$, are a bit more complicated since parameters
and return values have to be considered separately. On one hand the return
type can change covariantly with the type hierarchy and on the other hand
the parameters are only allowed to change in a contravariant way, i.e.,
change in the hierarchy upwards.

\begin{defn}[Method subtyping]
\label{def:methodSubtyping}
	\begin{mathpar}
		\inferrule*{X <: A\\B <: Y}{A \rightarrow B <: X \rightarrow Y}
	\end{mathpar}
\end{defn}

\subsubsection{Variance}
Variance classifies the type change within the type hierarchy. These
terms are introduced in category theory and were adopted to type theory
\cite{pierce_basic_1991}.

\begin{description}
	\item[Invariance] No type change is allowed.
	\item[Covariance] Type changes are only allowed downwards. If $B$
	<: $A$ and $Y$ <: $X$ and $A$ has a method with the return
	type of $Y$ then the return type of the same method in $A$
	has to be a subtype of $Y$, e.g., the return type can be $X$
	or $Y$ because of the reflexivity property of subtyping. For
	example $T \rightarrow Y$ <: $T \rightarrow X$ where $T$ is an 
	arbitrary type.
	\item[Contravariance] Contravariance is the opposite of
	covariance. Type changes are only allowed upwards in the type
	hierarchy. The type of function parameters are contravariance,
	e.g., $T \rightarrow A$ <: $T \rightarrow B$ if $B$ <: $A$ where
	$T$ is an arbitrary type.
\end{description}

\subsubsection{Liskov Substitution Principle}
\begin{quotation}
`Let $q(x)$ be a property provable about objects $x$ of type $T$. Then
$q(y)$ should be true for objects $y$ of type $S$ where $S$ is a subtype
of $T$.' -- Barbara Liskov \cite{liskov_behavioral_1999}
\end{quotation}

A formal and strong description of subtyping is given by Barbara
Liskov with her Liskov Substitution Principle, short LSP. This notion
of subtyping implies behavioural subtyping where the correctness
of the given properties should be provable. Since behavioural
subtyping would include a proof system which is generally undecidable
\cite{poll_behavioural_1998}. However, in languages without this strong
property, e.g., languages with signature subtyping, the type systems
can not proof the correctness of the program. In signature subtyping
the semantic of a program is not considered by the type system. Only 
the object and method signatures are important and checked by the system.

LSP allows to introduce a subsumption rule for type declarations:

\begin{defn}[Subsumption]
\label{def:methodSubtyping}
	\begin{mathpar}
		\inferrule*{x : A\\A <: B}{x : B}
	\end{mathpar}
\end{defn}

% TODO
%With the strong coupling of subtyping and subclassing in languages like
%Java, \cs or C++ the programmer has to decide between code reuse or proper
%subtyping. \Cref{sec:sharingTypes} gives a deeper insight of this problem.

\subsection{Sharing Types Versus Implementation}
\label{sec:sharingTypes}

Although the term \emph{class} is used in modern class-based
object-oriented languages like Java and C++, the concept of extension is
actually the concept of subtypes and not subclasses. The word type is in
the sense of data type, such as integer, boolean etc., but could also be
extended types like objects in object-oriented languages. They determine
the way data is stored and what operations can be perform on them.

In object-oriented languages like Java and C++, the type hierarchy
is directly linked to the implementation hierarchy, in other words,
inheritance automatically creates a subtype and there is no escape from
this. Of a practical point of view however, inheritance is merely a
mechanism to reuse code in further specialisations of classes. This
leads us to the first conflict: sharing types\todo{Heine: What are
sharing types?} vs implementation. To understand this have a look at
\Cref{fig:implementationConflict} \cite{simons_theory_2003-4}:

\begin{figure}[H]
	\centering
	\begin{emp}[classdiag](20, 20)
		Class.Shape("Shapes")()("+move(x, y):Integer", "+drawOn(c: Canvas)");
		Class.Ellipse("Ellipse")("f1, f2: Point", "r, s: Integer")();
		Class.Rectangle("Rectangle")("o: Point", "w, h: Integer")();
		Class.Circle("Circle")("{f1 = f2, r = s}")();
		Class.Square("Square")("{w = h}")();

		Ellipse.ne = Shape.s + (-10, -20);
		Rectangle.nw = Shape.s + (10, -20);
		Circle.n = Ellipse.s + (0, -20);
		Square.n = Rectangle.s + (0, -20);

		drawObjects(Shape, Ellipse, Rectangle, Circle, Square);
		link(inheritance)(Ellipse.n -- Shape.s);
		link(inheritance)(Rectangle.n -- Shape.s);
		link(inheritance)(Circle.n -- Ellipse.s);
		link(inheritance)(Square.n -- Rectangle.s);

		Class.Point("Point")("x, y: Integer")();

		Point.w = Shape.e + (100, 0);
		Class.CircleR("Circle")("r: Integer")();
		Class.SquareR("Square")("w: Integer")();
		Class.EllipseR("Ellipse")("p, q: Integer", "s: Integer")();
		Class.RectangleR("Rectangle")("h: Integer")();

		CircleR.ne = Point.s + (-10, -20);
		EllipseR.n = CircleR.s + (0, -20);
		SquareR.nw = Point.s + (10, -20);
		RectangleR.n = SquareR.s + (0, -20);

		drawObjects(Point, CircleR, SquareR, EllipseR, RectangleR);
		link(inheritance)(CircleR.n -- Point.s);
		link(inheritance)(EllipseR.n -- CircleR.s);
		link(inheritance)(SquareR.n -- Point.s);
		link(inheritance)(RectangleR.n -- SquareR.s);
	\end{emp}
	\caption{Sharing types vs implementation}
	\label{fig:implementationConflict}
\end{figure}

The left hierarchy expresses the conceptual family: A \emph{Circle}
is a special kind of \emph{Ellipse}, so is \emph{Square} of
\emph{Rectangle}. These objects do not actually `extend' their parents
though, instead, they rather remove properties. For instance, the
\emph{Circle} removes the property of having two radii. The hierarchy on
the right on the other hand is conceptual nonsense. It shows, however,
how one could want to derive and reuse code, in this case the x and
y coordinates. Because of that, inheritance (and reuse) of code and
subtyping should be treated differently.

\subsection{Binary Methods and the Problem of Recursive Closure}
\label{sec:recursiveClosure}
Another problem of the subtyping concept in object-oriented languages is
the problem of contravariance: the arguments of a method that is derived
and overwrites the same method in the super type can only have a more
general or same argument type, but not a more specific one:

\begin{figure}[H]
	\centering
	\begin{emp}[classdiag](20, 20)

		Class.A("A")()("+method(arg: T')");
		Class.B("B")()("+method(arg: T)");

		B.e = A.w + (-20, 0);
		drawObjects(A, B);
		link(inheritance)(B.e -- A.w);

	\end{emp}
	\caption{Contravariance: the argument type in \B is more specific than the one in \A}
	\label{fig:contravariance}
\end{figure}

This restriction makes perfectly sense for the type safety in
programming languages. For certain class constellations, it leads to
further problems though.

Assuming there is an object \emph{Animal} that has the method
\emph{mate} that takes an argument of the type \emph{Animal} and
returns a type \emph{Animal}. Intuitively, all other animal types
would be derived from this type, like \emph{Dog} or \emph{Cat} which
would have more specific arguments that accept only values of the type
of itself, so that dogs can only mate with dogs and cats only with
cats\cite{simons_theory_2003-1}. Figure \ref{fig:animalContravariance}
illustrates this situation. Because of the contravariance restriction
in subtyping this cannot be achieved by overriding the method with a
more specific argument type.

\begin{figure}[H]
	\centering
	\begin{emp}[classdiag](20, 20)

		Class.Animal("Animal")()("mate(Animal): Animal");
		Class.Dog("Dog")()("mate(Dog): Dog");
		Class.Cat("Cat")()("mate(Cat): Cat");

		Dog.ne = Animal.s + (-10, -25);
		Cat.nw = Animal.s + (10, -25);

		drawObjects(Animal, Dog, Cat);
		link(inheritance)(Dog.n -- Animal.s);
		link(inheritance)(Cat.n -- Animal.s);

	\end{emp}
	\caption{The arguments are more specific, which is not allowed because of the contravariance rule}
	\label{fig:animalContravariance}
\end{figure}

A similar problem arises in the method \emph{Object.equals: Object
$\rightarrow$ Boolean} in Java. The class \emph{Object} has an
implementation of the equals method that takes an argument of the type
\emph{Object}. All objects automatically are of the type \emph{Object}
in Java.    Because of the constraint of contravariance, it is unsound
to override this method with a more specific argument type which would
be reasonable since it does not make any sense to compare two objects
of different types. Instead, if a programmer wants to implement a new
version of this method, the use of type casts is inevitable.

To get rid of this, a language would need to specialise parameters
covariant. This is possible in Eiffel but this makes the type system
unsafe. Later, a type safe alternative will be presented.

\subsection{Schizophrenic Self-Reference}
\label{sec:schizoReferences}

\todo{Add bibliography}

In objects there has to be some recursion variable that refers to the
object itself, to be able to call methods or use values on self. In some
languages this is called \self or \emph{this}, in \ooplss
the term \self will be used to refer to this variable. \\

There are two main cases when recursion occurs:
\begin{enumerate}
	\item When a method accesses methods or properties of the self object
	\item When a method has arguments or return values of the same type as the object
\end{enumerate}

The first case is problematic when objects are derived; it is not
quite clear to which object the self variable should refer after
the derivation.  In C++ and Java, the self-reference in inherited
methods refers to the base object that was derived. This means that an
object may contain many versions of self-references, which is called
\emph{schizophrenic self-reference}. Other languages like Smalltalk
and Eiffel treat the self-reference differently; they redirect the
self-reference to the derived object. Consequently both models have
different semantics in recursion which are called naive respectively
mutual recursion \cite{cook_denotational_1995}.  Both are illustrated
in \Cref{fig:schizoRecursion}. $M$ derives $F$ which is a recursive
function. In the native case the call of the parent method, the recursion
is not changed which is different by mutual recursion where the recursive
call in $F$ is returned to the caller $M$.

\begin{figure}
	\centering
	\subfloat[Naive recursion]{
		\includedot[scale=0.7]{dot/naiveRecursion}
	}
	\subfloat[Mutual recursion]{
		\includedot[scale=0.7]{dot/mutualRecursion}
	}
	\caption{Naive and mutual recursion where M <: F \cite{cook_denotational_1995}}
	\label{fig:schizoRecursion}
\end{figure}

An example of schizophrenic self-reference for the second case is a
two dimensional vector type \emph{Vec2D} which has two coordinates and
the methods \emph{identity} and \emph{equals}. The identity method
returns the reference to the object itself and the equals method
compares two objects of this type. It therefore takes an argument
of the type \emph{Vec2D}. Assuming there is a subtype \emph{Vec3D}
that inherits all these methods, adds a z-coordinate and overrides the
equals method. Let us further assume that the rule of contravariance
does not apply here. Clearly the equals method of \emph{Vec3D} takes
an argument of the type \emph{vec3D}. Listing \ref{fig:schizoListing}
shows this constellation in Java.

\begin{lstlisting}[float,caption={An example of schizophrenic self-reference},label={fig:schizoListing}]
class Vec2D {
	int x,y;

	Vec2D identity() {
		return this; // A Vec2D self variable
	}

	boolean equals(Vec2D vec) {
		return vec.x == this.x && vec.y == this.y;
	}
}

class Vec3D extends Vec2D {
	int z;

	boolean equals(Vec2D vec) {
		// Self is of Vec3D type
		if (vec instanceof Vec3D)
			// Uses insecure type casting
			return super.equals(vec) && this.z == ((Vec3D)vec).z;

		return false;
	}
}
\end{lstlisting}

In the derived class \emph{Vec3D} the self reference in the equals 
method refers to a \emph{Vec3D} object while the one in the identity method
refers to a \emph{Vec2D} object. This is why an instance of the class
\emph{Vec3D} would be schizophrenic.

This is how the fixation of self-references is done in the subtyping
concept; before the combination respectively extension of the objects. In the
concept of subclassing however, it is done after the combination.

\subsection{Subclassing} \todo{Cite}
The goal of the concept of subclassing is now to provide a
different kind of inheritance. With this inheritance, the programmer
should be able to inherit code without automatically creating a subtype.
This solves the problem described in \Cref{sec:sharingTypes}. Since
subclassing does not create subtypes, the restriction of contravariance,
described in \Cref{sec:recursiveClosure}, is of no relevancy
anymore. And as already mentioned, the fixation of the self references
and types is done after the inheritance, so there will be no schizophrenic
self-references as described in the first case in \Cref{sec:schizoReferences}.  
\todo{are they cases clear structured?}

In subclassing however, the question rises: how should return values and
arguments be typed (see the second case in \Cref{sec:schizoReferences})
when defining the methods and data fields, since the programmer is not able to
know of what type the subclass will be. This is why there has to be some
sort of placeholder for such cases: the \emph{MyType}. The \emph{MyType}
placeholder is then substituted with the current type after the
inheritance respectively after the inheritance in a subtyping environment.
\todo{Some further explanations are necessary}

\section{Making Subclassing Practical}
\label{ctr:makingSubclassingPractical}
% estimated pages: 2-3
Subtyping is one of the most fundamental and most well known relation
between recursive types in today's programming languages. In languages
where subclasses do not implicitly define subtypes a more general
relation is needed -- \emph{matching} -- which is weaker and does
not support subsumption. Originally \emph{matching} was proposed as
function-bounded subtyping \cite{canning_f-bounded_1989}. Function-bounded
subtyping extends simple subtyping with parametrisation which is
popular as \emph{generics} in well known programming languages
like Java or \cs \cite{barron-estrada_inheritance_2003}. An other
interpretation of \emph{matching} as higher-order subtyping with
better properties like reflexivity and transitivity was shown in
\cite{abadi_subtyping_1996}. This interpretation is more
difficult for the users of the language since the semantic is complex
and not easy to understand in every circumstance because subtyping is
on object generator level. However, this is specified for structural
type systems and not for nominals. Restricting higher-order subtyping
for nominal type systems makes the semantic more clear less complex in use.

\subsection{Nominal and Structural Type Systems}
Generally two different kinds of type system can be distinguished
depending on how type relations are determined. The first and most
flexible technique is provided by a structural type system which is used
in more sophisticated languages and research topics. Structural type
system does not take regard to the object combination operators which
are used but rather take care on the object's structure to determine the
relations between two objects. The other family of type systems are from
nominal nature which is used in popular languages like Java, \cs, C++
and many more. For nominal type systems the type relation between objects
is specified with keywords that are used for class combination. For
example, Java provides an 'extends` keyword which does the combination
and restricts the programmer to define only classes that are in subtype
relation to its parent. This restriction is not available in structural
ones which are more complicated in type checking where in nominal the
relation is specified explicitly.

\subsection{Matching}
\label{subsec:matching}
\begin{prop}[Matching]
	\label{prop:matching}
	Bruce defines matching as `the same as subtyping in the absence
	of the \emph{MyType} construct, but differs in the presence of
	\emph{MyType}, because \emph{MyType} implicitly has different
	meanings in different types.' -- \cite{bruce_foundations_2002}
\end{prop}

An solution proposed by Bruce \cite{bruce_binary_1995} is
\emph{matching}. Matching is a generalised subtyping relation, written
as `\match', between two types and takes regard to a \emph{MyType} in
subclasses. An important difference is that the matching relation is only
between object types and not on method types like it is in subtyping. As
said by Bruce in \cite{bruce_foundations_2002} matching does not differ
very much from subtyping except that \mytype is not substituted by its
concrete object type. This makes the relation weaker than subtyping
where contravariant method parameters are not allowed.

\begin{defn}[Matching]
	\label{defn:matching}
	\todo{give formal definition}
\end{defn}

Listing \ref{lst:javaBinary} contains some problems that can not be tackled
with subtyping. First of all the variable in line \ref{lst:javaBinary0} can
not be specialised since it is invariant. This entails that even when the 
method \emph{getNext} can be specialised in the subclass -- which is not possible
in Java -- a cast operation is necessary to get the correct type in the overridden 
method on line \ref{lst:javaBinary1}.

The second problem is in line \ref{lst:javaBinary2}. Since there is a covariant 
method parameter the method can not be typed. This implies that there are no statically
checks to prevent the programmer from adding \emph{SinglyLinkedNode} objects to a 
\emph{DoublyLinkedNode}.

\begin{lstlisting}[float,caption={Illegal subtyping of binary methods in Java},label={lst:javaBinary}]
public class SinglyLinkedNode {
	private SinglyLinkedNode next; %\label{lst:javaBinary0})

	public void setNext(SinglyLinkedNode next) {
		this.next = next;
	}

	public SinglyLinkedNode getNext() {
		return this.next;
	}
}

public class DoublyLinkedNode extends SinglyLinkedNode {
	private DoublyLinkedNode prev;
	public setPrev(DoublyLinkedNode prev) {
		this.prev = prev;
		prev.next = this;
	}

	public DoublyLinkedNode getPrev() {
		return this.prev;
	}
	
	// Overloaded method in Java.
	%\label{lst:javaBinary2})public void setNext(DoublyLinkedNode next) {
			this.next = next;
			next.prev = this;
	}

	public DoublyLinkedNode getNext() {
		%\label{lst:javaBinary1})return (DoublyLinkedNode)this.next;
	}
}
\end{lstlisting}

Listing \ref{lst:break} illustrates what behaviour would be possible if subtyping 
would allow covariant parameters.

\begin{lstlisting}[float,label={lst:break},caption={Breaking a doubly linked node}]
pubic void breaks(SinglyLinkedNode one, SinglyLinkedNode other) {
	one.setNext(other);
}
\end{lstlisting}

When the subclassing rules are defined they can be formulated
type safe, so that subclasses match their superclasses. With
this assumption subclasses and superclasses are matching related and
nominal matching is possible for type checking. With this definition
the relation\emph{DoublyLinkedNode} \match \emph{SinglyLinkedNode} holds.

Since matching is a weaker relation than subtyping the assumption of $a:A$
and $A$ \match $B$ does not imply $a:B$ like subtyping does, i.e., matching
can not help in situations illustrated in Listing \ref{lst:matchbreak}.

\begin{lstlisting}[float,label={lst:matchbreak},caption={Matching relation in the break method}]
pubic void break(node <# SinglyLinkedNode) {
	SinglyLinkedNode newNode = new SinglyLinkedNode();
	node.setNext(newNode);
}
\end{lstlisting}

One can see that in this case matching is too weak. Without subsumption the type system
can not know that \emph{newNode} is compatible with the object passed as parameter.

\subsubsection{Match-Bounded Quantification}
However, the example in Listing \ref{lst:break} is still not correctly
typeable as long as it is only known that the matching relation between
\emph{DoublyLinkedNode} and \emph{SinglyLinkedNode} holds since assigning
objects to variable is not safe if only is known that the variable's type
matches the object type. \todo{difficult}

This is desirable in homogeneous data structures
but not in heterogeneous ones. Therefore, matching and \mytype together is a good match
for such structures but lacks on flexibility for many other situations.

To tackle such unwanted inflexibility matching can be extended
with type parametrisation, called match-bounded quantification
\cite{abadi_subtyping_1996}. 

\subsection{Type Operators}
A type operator is a function on type level mapping types to types. Type
operators are important for the formal specification of matching and
understanding of the concepts. In an object-oriented language the object
type can be considered as a record type, e.g., an object type with two
fields of type \emph{Nat} and \emph{Bool}: \{a:Nat, b:Bool\}. If not
every type is fully specified an expression can be typed with a type
variable. For this a type operator is a function, the lambda-calculus
expression is used, from types to types: \[A_{Op} := \lambda X.A(X)
\] where $A := \{a:Nat, b:X\}$. Objects in object-oriented languages are
recursive since they make heavy use of the self-type. However, since a
function in the lambda calculus can not be recursive per se a special
construct is needed \cite{gabriel_why_1988}.  To hide the complexity of
the recursion theorem the $\mu$-convection is used. A $\mu$-function is
to understand similar to a $\lambda$-function with the difference that
the parameter will get bound recursively \cite{simons_theory_2002-3}.

This can now be used to define the fixpoint of $A$ and is written as \[A^*
:= \mu X.A_{Op}(X).\]

\todo{(un)folding property and typing problems, other reference than simons}

\subsection{Matching as F-Bounded Subtyping}
F-bounded subtyping\footnote{Abbreviates function-bounded subtyping}
is an extension to simple subtyping by adding parametrisation to
types. F-bounded subtyping relation is often called \emph{generics}
and is written as $X$<:$B_{Op}(X)$ and gives the information that $X$
extends $B$. The use of the bound against the type operator of $B$
shows the function in the bound. Considering an example in Java in
Listing \ref{lst:generics} shows how this concept is implemented in a popular
programming language. Since every type that satisfies the f-bound can
be used to replace the type parameter $X$, the formal type of $A$ is
$\forall(X$<:$B(X))A\{X\}$ where the bound is \emph{not} against the 
type operator!

\begin{lstlisting}[float,caption={Universal quantified f-bound in Java},label={lst:generics}]
public class A<X extends B<X>> {
	public void m(X x) {
		x.someMethodOfB();
	}
}
\end{lstlisting}

Here, both cases have be considered very carefully. In the f-bounded subtype
relation where the bound is a real function, i.e., type operator,
the self reference is not yet bound whereas in generics in Java the self
reference is already bound. As long as the type operator is not evaluated
the subtyping relation is easier to hold than afterwards. This enables 
parametrisation over every extension of an object type and not only over
every subtype if it.

In this case matching is defined as\cite{abadi_subtyping_1996}
\begin{defn}[Matching as F-Bounded Subtyping]
	\label{def:matchingAsBound}
	$A \textnormal{\match} B := A <: B_{Op}(A)$\\
	$\forall (X \textnormal{\match} A)B\{X\} := \forall (X <: A_{Op}(X))B\{X\}$
\end{defn}

\subsection{Matching as Higher-Order Subtyping}
Higher-order subtyping is the second interpretation of matching
done by Abadi and Cardelli. It is the counterpart interpretation
to the f-bounded subtyping interpretation which was the first of
matching. The main difference is that here the relation is defined
between the type generators and not between a type which is bound by a
type generator. Since a type generator can be expressed as lambda term,
it is formally a subtyping relation between two functions that are
generating objects and takes types as parameters to bind the self type.
Consequently these object generators are in proper subtyping relation.

In this case matching is defined as\cite{abadi_subtyping_1996}
\begin{defn}[Matching as Higher-Order Subtyping]
	\label{def:matchingAsBound}
	$A \textnormal{\match} B := A_{Op} <: B_{Op}(A)$\\
	$\forall (X \textnormal{\match} A)B\{X\} := \forall (X_{Op} <: A_{Op}(X))B\{X\}$
\end{defn}

This shows that now on both sides of the subtyping relation is a type
generator.  Since now there is no fixpoint mixed with the generators
the same properties as subtyping between to functions, i.e., reflexivity
and transitivity is true.
%
%TODO Ruben: write this section
%\subsection{Example with Matching}

