
\part{Theoretical Background}
\chapter{Subtyping vs. Subclassing}
In this chapter we want you to get familiar with the terms subtyping
and subclassing and their differences.  \\

\section{Sharing types versus implementation}
Although we are familiar with the term class in most modern object oriented
programming languages like C++ and Java, these are actually types in the sense
of subtyping theory. In these languages, the type hierarchy is directly linked
to the implementation hierarchy, in other words, inheritance automatically 
creates a subtype. Of a theoretical point of view however, inheritance is merely
a mechanism to reuse code in further specialisations of classes. This leads us
to the first conflict: sharing types vs. the implementation. To understand this
have a look at example \ref{fig:implementationConflict} \cite{simons_theory_2003-4}: % reference to simons?

\begin{figure}[H]
\center
\begin{emp}[classdiag](20, 20)

Class.Shape("Shapes")()("+move(x, y):Integer", "+drawOn(c: Canvas)");
Class.Ellipse("Ellipse")("f1, f2: Point", "r, s: Integer")();
Class.Rectangle("Rectangle")("o: Point", "w, h: Integer")();
Class.Circle("Circle")("{f1 = f2, r = s}")();
Class.Square("Square")("{w = h}")();

Ellipse.ne = Shape.s + (-10, -20);
Rectangle.nw = Shape.s + (10, -20);
Circle.n = Ellipse.s + (0, -20);
Square.n = Rectangle.s + (0, -20);

drawObjects(Shape, Ellipse, Rectangle, Circle, Square);
link(inheritance)(Ellipse.n -- Shape.s);
link(inheritance)(Rectangle.n -- Shape.s);
link(inheritance)(Circle.n -- Ellipse.s);
link(inheritance)(Square.n -- Rectangle.s);

Class.Point("Point")("x, y: Integer")();

Point.w = Shape.e + (100, 5);
Class.CircleR("Circle")("r: Integer")();
Class.SquareR("Square")("w: Integer")();
Class.EllipseR("Ellipse")("p, q: Integer", "s: Integer")();
Class.RectangleR("Rectangle")("h: Integer")();

CircleR.ne = Point.s + (-10, -20);
EllipseR.n = CircleR.s + (0, -20);
SquareR.nw = Point.s + (10, -20);
RectangleR.n = SquareR.s + (0, -20);

drawObjects(Point, CircleR, SquareR, EllipseR, RectangleR);
link(inheritance)(CircleR.n -- Point.s);
link(inheritance)(EllipseR.n -- CircleR.s);
link(inheritance)(SquareR.n -- Point.s);
link(inheritance)(RectangleR.n -- SquareR.s);

\end{emp}
\caption{Sharing types vs. implementation}
\label{fig:implementationConflict}
\end{figure}

The left hierarchy expresses the conceptual family: A Circle is a special
kind of an Ellipse, so is Square of a Rectangle, and these are all a Shape.
The hierarchy on the right however shows how one could derive properties and 
add variables or methods to the type. The Circle on the left, however, does
not actually ''extend`` the Ellipse, since it does not add properties, instead
it rather removes the property of having two radii. The right hierarchy in return
is conceptual nonsense, since a Circle is not a kind of Point. Because of that,
we want to use extended concepts of classification and typing, which will be
explained later.

\section{Problem of recursive closure}
Another problem of the subtyping concept we nowadays have in most object 
oriented languages is the problem of contravariance: the arguments of a method
that is derived from a super type and overwrites the method in the super type
can only have a wider or same argument type, but not a narrower one: 
\begin{figure}[H]
\center
\begin{emp}[classdiag](20, 20)

Class.A("A")()("method(arg: T')");
Class.B("B")()("method(arg: T)");

B.e = A.w + (-20, 0);
drawObjects(A, B);
link(inheritance)(B.e -- A.w);

\end{emp}
\caption{Contravariance: the argument type in B is more specific than the one in A}
\label{fig:contravariance}
\end{figure}

This restriction makes perfectly sense for the type security in programming
languages. For certain it leads to \cite{simons_theory_2003-1}



--
A type is closed in the sense of being complete whereas a class is open ended
in the sense of being subject to arbitrary subdivision and further 
specialisation.

class is a type family

Obligations for subtype methods

problem of recursive closure  java example with object.equal

modern oo languages type hierarchy is directly linked to implementation hierarchy

% estimated pages: 4
\chapter{Matching}
% estimated pages: 2-3
Subtyping is one of the most fundamental property in object-oriented languages
in todays ....

\section{Matching as F-Bounded Subtyping}

\section{Matching as Higher-Order Subtyping}
