
\part{Theoretical Background}
<<<<<<< HEAD
<<<<<<< HEAD
A introduction is still missing
=======
\chapter{Binary Methods}
>>>>>>> Doc: Todo command added
\todo{Introduction to typing problems and matching}

\chapter{Subtyping vs. Subclassing}
\label{chap:subtypingVsSubclassing}
=======
A introduction is still missing
\todo{Introduction to typing problems and matching}

\chapter{Subtyping vs. Subclassing}
<<<<<<< HEAD
\label{cpt:subtypingVsSubclassing}
>>>>>>> Doc: Binary Methods
=======
\label{chap:subtypingVsSubclassing}
>>>>>>> Doc: Introduced matching
In this chapter we want you to get familiar with the terms subtyping
and subclassing and their differences. Both concepts exist in some of
the widely known object oriented programming languages like Java or C++,
but are usually mixed up.

\section{Sharing types versus implementation}
\label{sec:sharingTypes}

Although the term \emph{class} is used in modern object oriented
languages like Java and C++, the concept behind it is actually the
concept of subtypes.	The word type is in the sense of data type, such
as integer, boolean etc., but could also be extended types like objects
in object oriented languages. They determine the way data is stored and
what operations can be done on them.

In object oriented languages like Java and C++, the type hierarchy
is directly linked to the implementation hierarchy, in other words,
inheritance automatically creates a subtype. Of a \todo{Is not theorecital. It's a practical point}theoretical point
of view however, inheritance is merely a mechanism to reuse code in
further specialisations of classes. This leads us to the first conflict:
sharing types vs. the implementation. To understand this have a look at
example \ref{fig:implementationConflict} \cite{simons_theory_2003-4}:
% reference to simons?

\begin{figure}[H]
\center
\begin{emp}[classdiag](20, 20)

Class.Shape("Shapes")()("+move(x, y):Integer", "+drawOn(c: Canvas)");
Class.Ellipse("Ellipse")("f1, f2: Point", "r, s: Integer")();
Class.Rectangle("Rectangle")("o: Point", "w, h: Integer")();
Class.Circle("Circle")("{f1 = f2, r = s}")();
Class.Square("Square")("{w = h}")();

Ellipse.ne = Shape.s + (-10, -20);
Rectangle.nw = Shape.s + (10, -20);
Circle.n = Ellipse.s + (0, -20);
Square.n = Rectangle.s + (0, -20);

drawObjects(Shape, Ellipse, Rectangle, Circle, Square);
link(inheritance)(Ellipse.n -- Shape.s);
link(inheritance)(Rectangle.n -- Shape.s);
link(inheritance)(Circle.n -- Ellipse.s);
link(inheritance)(Square.n -- Rectangle.s);

Class.Point("Point")("x, y: Integer")();

Point.w = Shape.e + (100, 5);
Class.CircleR("Circle")("r: Integer")();
Class.SquareR("Square")("w: Integer")();
Class.EllipseR("Ellipse")("p, q: Integer", "s: Integer")();
Class.RectangleR("Rectangle")("h: Integer")();

CircleR.ne = Point.s + (-10, -20);
EllipseR.n = CircleR.s + (0, -20);
SquareR.nw = Point.s + (10, -20);
RectangleR.n = SquareR.s + (0, -20);

drawObjects(Point, CircleR, SquareR, EllipseR, RectangleR);
link(inheritance)(CircleR.n -- Point.s);
link(inheritance)(EllipseR.n -- CircleR.s);
link(inheritance)(SquareR.n -- Point.s);
link(inheritance)(RectangleR.n -- SquareR.s);

\end{emp}
\caption{Sharing types vs. implementation}
\label{fig:implementationConflict}
\end{figure}

The left hierarchy expresses the conceptual family: A \emph{Circle}
is a special kind of an \emph{Ellipse}, so is \emph{Square} of
a \emph{Rectangle}. These objects do not actually ''extend`` their
parents though, instead, they rather remove properties. For instance, the
\emph{Circle} removes the property of having two radii.	The hierarchy on
the right on the other hand is conceptual nonsense. It shows, however,
how one could want to derive and reuse code, in this case the x and
y coordinates. Because of that, inheritance (and reuse) of code and
subtyping should be treated differently.

\section{Problem of recursive closure}
\label{sec:recursiveClosure}
Another problem of the subtyping concept we nowadays have in most object
oriented languages is the problem of contravariance: the arguments of
<<<<<<< HEAD
<<<<<<< HEAD
a method that is derived	and overwrites the same method in the super
=======
a method that is derived  and overwrites the same method in the super
>>>>>>> Doc: Introduced matching
=======
a method that is derived	and overwrites the same method in the super
>>>>>>> Doc: spaces to tabs
type can only have a more general or same argument type, but not a more
specific one:

\begin{figure}[H]
\center
\begin{emp}[classdiag](20, 20)

Class.A("A")()("+method(arg: T')");
Class.B("B")()("+method(arg: T)");

B.e = A.w + (-20, 0);
drawObjects(A, B);
link(inheritance)(B.e -- A.w);

\end{emp}
\caption{Contravariance: the argument type in B is more specific than the one in A}
\label{fig:contravariance}
\end{figure}

This restriction makes perfectly sense for the type security in
programming languages. For certain class constellations, it leads to
further problems though.

Assuming there is a object \emph{Animal} that has the method
\emph{mate} that takes an argument of the type \emph{Animal} and
returns a type \emph{Animal}. Intuitively, all other animal types
would be derived from this type, like \emph{Dog} or \emph{Cat} which
would have more specific arguments that accept only values of the type
of itself, so that dogs can only mate with dogs and cats only with
cats\cite{simons_theory_2003-1}. Figure \ref{fig:animalContravariance}
illustrates this situation. Because of the contravariance restriction
in subtyping this cannot be achieved by overriding the method with a
more specific argument type.

\begin{figure}[H]
\center
\begin{emp}[classdiag](20, 20)

Class.Animal("Animal")()("mate(Animal): Animal");
Class.Dog("Dog")()("mate(Dog): Dog");
Class.Cat("Cat")()("mate(Cat): Cat");

Dog.ne = Animal.s + (-20, -20);
Cat.nw = Animal.s + (20, -20);

drawObjects(Animal, Dog, Cat);
link(inheritance)(Dog.n -- Animal.s);
link(inheritance)(Cat.n -- Animal.s);

\end{emp}
\caption{The arguments are more specific, which is not allowed because of the contravariance rule}
\label{fig:animalContravariance}
\end{figure}

A similar problem arises in the method \emph{Object.equals: Object
$\rightarrow$ Boolean}\footnote{For those not familiar with this
notation: Object.equals: Object $\rightarrow$ Boolean means that
the equals method/function takes an Object and returns a Boolean}
in Java. The class \emph{Object} has an implementation of the equals
method that takes an argument of the type \emph{Object}. All objects
<<<<<<< HEAD
<<<<<<< HEAD
automatically are of the type \emph{Object} in Java.	Because of the
=======
automatically are of the type \emph{Object} in Java.  Because of the
>>>>>>> Doc: Introduced matching
=======
automatically are of the type \emph{Object} in Java.	Because of the
>>>>>>> Doc: spaces to tabs
constraint of contravariance, it is not sound to override this method
with a more specific argument type which would be reasonable since it does
not make any sense to compare two objects of different types. Instead,
if the programmer wants to implement a new version of this method, he
has to use instanceof to check whether the given object is of the same
type. A much more elegant solution would be to let the type system of
the programming language do the checking.\\

\section{Schizophrenic self-reference}
\label{sec:schizoReferences}

In objects there has to be some recursion variable that refers to the
object itself, to be able to call methods or use values on self . 
In some languages this is called \emph{self} or \emph{this}, in
this explanation, the term self will be used to refer to this variable. \\

There are two main cases when recursion occurs:
\begin{enumerate}
\item When a method accesses methods or properties of the self object
\item When a method has arguments or return values of the same type as the object
\end{enumerate}

The first case is problematic when objects are derived: it is not quite
clear to which object the self variable should refer after the derivation.
In C++ and Java, the self-reference in inherited methods refers to the
base object that was derived. This means that an object may contain
many versions of self-references, which is called \emph{schizophrenic
self-reference}. Other languages like Smalltalk and Eiffel treat the
self-reference differently: they redirect the self-reference to the
derived object. \\

An example of shizophrenic self-reference could be a two dimensional
vector type \emph{Vec2D} which has two coordinates and the methods
\emph{identity} and \emph{equals}. The identity method returns the
reference to the object itself and the equals method compares two
objects of this type. It therefore takes an argument of the type
\emph{Vec2D}. Assuming there is a subtype \emph{Vec3D} that inherits
all these methods, adds a z coordinate and overrides the equals
method. Let us further assume that the rule of contravariance does not
apply here. Clearly the equals method of \emph{Vec3D} takes an argument
of the type \emph{vec3D}. Listing \ref{fig:schizoListing} shows this
constellation (in pseudo-code):

\begin{lstlisting}[caption={An example of schizophrenic self-reference},label={fig:schizoListing}]
class Vec2D {
	int x,y;

	Vec2D identity() {
		return self;
	}

	bool equals(Vec2D vec) {
		return vec.x == self.x && vec.y == self.y;
	}
}

class Vec3D extends Vec2D {
	int z;

	bool equals(Vec2D vec) {
		return vec.x == self.x && vec.y == self.y && vec.z == self.z;
	}
}
\end{lstlisting}

In the derived class \emph{Vec3D} the self reference in the equals 
method refers to a \emph{Vec3D} object while the one in identity
refers to a \emph{Vec2D} object. This is why an instance of the class
\emph{Vec3D} would be schizophrenic.

This is how the fixation of self-references is done in the subtyping
concept: before the combination (i.e. inheritance) of the objects. In the
concept of subclassing however, it is done after the combination.

\section{Subclassing}

The goal of the concept of subclassing is now to provide a somewhat
different kind of inheritance. With this inheritance, the programmer should
be able to inherit code without automatically creating a subtype. 
\todo{Mention here that our programming language will support both?}
This solves the problem described in section \ref{sec:sharingTypes}. Since
subclassing does not create subtypes, the restriction of contravariance, 
described in section \ref{sec:recursiveClosure}, is of no relevancy
anymore. And as already mentioned, the fixation of the self
references and types is done after the inheritance, so there will be no
schizophrenic self-references as described in case 1 in 
\ref{sec:schizoReferences}. \\

In subclassing however, the question rises: how should return values
and arguments be typed (see case 2 in \ref{sec:schizoReferences})
when defining the methods and fields, since the programmer is not able
to know of what type the subclass will be. This is why there has to
be some sort of placeholder for such cases: the \emph{MyType}. The
\emph{MyType} placeholder is then substituted with the current type
after the inheritance.
% TODO: Needs further explanations

<<<<<<< HEAD
<<<<<<< HEAD
\chapter{Making subclassing practical}
=======
\chapter{Matching}
>>>>>>> Doc: Binary Methods
% estimated pages: 2-3
=======
\chapter{Making subclassing practical}
% estimated pages: 2-3
<<<<<<< HEAD

>>>>>>> Doc: Introduced matching
=======
>>>>>>> Doc: Language Principles and Background added
Subtyping is one of the most fundamental and most well known relation
between recursive types in today's programming languages. In languages
where subclasses not implicitly define subtypes a more general
relation is needed - \emph{matching} - which is weaker and does
not support subsumption. Originally \emph{matching} was proposed
as F-bounded subtyping \cite{canning_f-bounded_1989}. F-bounded
subtyping extends simple subtyping with parametrisation which is as
\emph{generics} in well known programming languages like Java or \CS
\cite{barron-estrada_inheritance_2003}. An other interpretation of
\emph{matching} as higher-order subtyping with better properties in
reflexivity and transitivity was shown \cite{abadi_subtyping_1996}.

\section{Binary Methods}
A binary method is a method with parameters of the same type as the
receiver of the method, i.e., the \emph{self} reference in the method. The
name has the origins in the fact that such methods are binary relations
mapping to a codomain, e.g., \emph{equal} of type $X \times X \rightarrow
Boolean$ or \emph{add} of type $Num \times Num \rightarrow Num$. The
same behaviour can be observed in homogeneous data structures. Typing
such function in functional languages are straightforward and does not
rise difficulties. This looks complete different in statically object-oriented
languages where subtyping is fundamental \cite{bruce_binary_1995}.

<<<<<<< HEAD
<<<<<<< HEAD
\autoref{lst:javaBinary} shows how subtyping can not prevent the
possibility to add objects of type \emph{SinglyLinkedNode} in a
\emph{DoublyLinkedNode} which is definitely incorrect and has to end
in a runtime exception. In subtyping existing object state variables
and methods like \emph{setNext} can not be further specialised. The
\autoref{lst:javaBinary1} shows how the type system has to be escaped
by casts which is unsafe and.	However, these problems does not rise
from binary methods them self but in combination with subtyping and
inheritance since these concepts are associated with subsumption.

\begin{lstlisting}[caption={Illegal subtyping of binary methods in Java},label={lst:javaBinary}]
public class SinglyLinkedNode {
	private SinglyLinkedNode next;

	public setNext(SinglyLinkedNode next) {
		this.next = next;
	}

	public getNext() SinglyLinkedNode {
		return this.next;
	}
=======
Listing \ref{lst:javaBinary} shows how nominal subtyping would provide
the possibility to add objects of type \emph{SinglyLinkedNode} in a
\emph{DoublyLinkedNode} which is definitely incorrect. However, these
problems does not rise from binary methods them self but in combination
with subtyping and inheritance since these concepts are associated
with subsumption.

\begin{listing}
\begin{lstlisting}
=======
\autoref{lst:javaBinary} shows how subtyping can not prevent the
possibility to add objects of type \emph{SinglyLinkedNode} in a
\emph{DoublyLinkedNode} which is definitely incorrect and has to end
in a runtime exception. In subtyping existing object state variables
and methods like \emph{setNext} can not be further specialised. The
\autoref{lst:javaBinary1} shows how the type system has to be escaped
by casts which is unsafe and.	However, these problems does not rise
from binary methods them self but in combination with subtyping and
inheritance since these concepts are associated with subsumption.

\begin{lstlisting}[caption={Illegal subtyping of binary methods in Java},label={lst:javaBinary}]
>>>>>>> Doc: Code listings adapted. Node example enhanced
public class SinglyLinkedNode {
	private SinglyLinkedNode next;

	public setNext(SinglyLinkedNode next) {
		this.next = next;
	}

	public getNext() SinglyLinkedNode {
		return this.next;
	}
}

public class DoublyLinkedNode extends SinglyLinkedNode {
	private DoublyLinkedNode prev;
	public setPrev(DoublyLinkedNode prev) {
		this.prev = prev;
		prev.next = this;
	}

	public DoublyLinkedNode getPrev() {
		return this.prev;
	}
	
	// Not typeable expression in Java.
	public setNext(DoublyLinkedNode next) {
			this.next = next;
			next.prev = this;
	}

	// Legal override in the sense of subtyping. Illegal Java;
	public DoublyLinkedNode getNext() {
		%\label{lst:javaBinary1})return (DoublyLinkedNode)this.next;
	}
}
\end{lstlisting}

Assuming \emph{DoublyLinkedNode} is a subtype of \emph{SinglyLinkedNode},
the code in \autoref{lst:break} can create a run time exception. As
long as both parameters are objects of the exact same type the code runs
without any problem. On the other side if the parameter are from different
types an runtime error would occur since the parameter of \emph{setNext}
does not provide a \emph{prev} field.

\begin{lstlisting}[label={lst:break},caption={Breaking a doubly linked node}]
pubic void breaks(SinglyLinkedNode one, SinglyLinkedNode other) {
	one.setNext(other);
}
\end{lstlisting}

Bruce showed in \cite{bruce_binary_1995} some ways out of such problems
like avoiding binary methods at all and provide these methods as static
functions or providing special pair objects providing these binary
methods. One may argue that it should be possible to change the parameters
of the objects in a contravariant way, i.e., that \emph{setNext}
and \emph{getNext} is typed as a method with parameters of type
\emph{DoublyLinkedNode}. As seen in \autoref{chap:subtypingVsSubclassing}
this would break the subtyping relation between \emph{SinglyLinkedNode}
and \emph{SinglyLinkedNode}. In this case inheritance provides a subclass
which is not a subtype.

\section{Matching}
\begin{quotation}
"the same as subtyping in the absence of the \emph{MyType}
construct, but differs in the presence of \emph{MyType}, because
\emph{MyType} implicitly has different meanings in different types." -
\cite{bruce_foundations_2002}
\end{quotation}

<<<<<<< HEAD
  max(other:MyType):MyType {
    if (other.n > self.n)
      return other;
    return self;
  }
>>>>>>> Doc: Binary Methods
}

public class DoublyLinkedNode extends SinglyLinkedNode {
	private DoublyLinkedNode prev;
	public setPrev(DoublyLinkedNode prev) {
		this.prev = prev;
		prev.next = this;
	}

	public DoublyLinkedNode getPrev() {
		return this.prev;
	}
	
	// Not typeable expression in Java.
	public setNext(DoublyLinkedNode next) {
			this.next = next;
			next.prev = this;
	}

	// Legal override in the sense of subtyping. Illegal Java;
	public DoublyLinkedNode getNext() {
		%\label{lst:javaBinary1})return (DoublyLinkedNode)this.next;
	}
}
\end{lstlisting}
<<<<<<< HEAD

Assuming \emph{DoublyLinkedNode} is a subtype of \emph{SinglyLinkedNode},
the code in \autoref{lst:break} can create a run time exception. As
long as both parameters are objects of the exact same type the code runs
without any problem. On the other side if the parameter are from different
types an runtime error would occur since the parameter of \emph{setNext}
does not provide a \emph{prev} field.

\begin{lstlisting}[label={lst:break},caption={Breaking a doubly linked node}]
pubic void breaks(SinglyLinkedNode one, SinglyLinkedNode other) {
	one.setNext(other);
}
\end{lstlisting}
<<<<<<< HEAD
=======
\caption{Max and MinMax protocol}
\label{fig:minmax-example}
\end{listing}
=======
>>>>>>> Doc: Code listings adapted. Node example enhanced

\section{Type Operators}
>>>>>>> Doc: Binary Methods

Bruce showed in \cite{bruce_binary_1995} some ways out of such problems
like avoiding binary methods at all and provide these methods as static
functions or providing special pair objects providing these binary
methods. One may argue that it should be possible to change the parameters
of the objects in a contravariant way, i.e., that \emph{setNext}
and \emph{getNext} is typed as a method with parameters of type
\emph{DoublyLinkedNode}. As seen in \autoref{chap:subtypingVsSubclassing}
this would break the subtyping relation between \emph{SinglyLinkedNode}
and \emph{SinglyLinkedNode}. In this case inheritance provides a subclass
which is not a subtype.
=======
An other solution proposed by Bruce \cite{bruce_binary_1995}\todo{Correct
reference since he proposed the idea earlier} is
\emph{matching}. Matching is a generalised subtyping relation, written
as \match, between two types and takes regard to a \emph{MyType} in
subclasses. An important difference is that the matching relation is only
between object types and not on method types what is in subtyping. As
said by Bruce in \cite{bruce_foundations_2002} matching does not differ
very much from subtyping only that \MyType is not substituted by its
concrete object type. This makes the relation weaker than subtyping
where contravariant method parameters are not allowed.

When the subclassing rules are defined they can be formulated
type safe that subclasses are matching their superclasses. With
this assumption subclasses and superclasses are matching related and
nominal matching is possible for type checking. With this definition
the relation\emph{DoublyLinkedNode} \match \emph{SinglyLinkedNode} holds.



%\begin{lstlisting}[label={lst:matchbreak},caption={Matching relation in the break method}]
%pubic void break(SinglyLinkedNode node) {
%	SinglyLinkedNode newNode = new SinglyLinkedNode();
%	node.setNext(newNode);
%}
%\end{lstlisting}


>>>>>>> Doc: Introduced matching

\section{Matching}
\begin{quotation}
"the same as subtyping in the absence of the \emph{MyType}
construct, but differs in the presence of \emph{MyType}, because
\emph{MyType} implicitly has different meanings in different types." -
\cite{bruce_foundations_2002}
\end{quotation}

An other solution proposed by Bruce \cite{bruce_binary_1995}\todo{Correct
reference since he proposed the idea earlier} is
\emph{matching}. Matching is a generalised subtyping relation, written
as \match, between two types and takes regard to a \emph{MyType} in
subclasses. An important difference is that the matching relation is only
between object types and not on method types what is in subtyping. As
said by Bruce in \cite{bruce_foundations_2002} matching does not differ
very much from subtyping only that \MyType is not substituted by its
concrete object type. This makes the relation weaker than subtyping
where contravariant method parameters are not allowed.

When the subclassing rules are defined they can be formulated
type safe that subclasses are matching their superclasses. With
this assumption subclasses and superclasses are matching related and
nominal matching is possible for type checking. With this definition
the relation\emph{DoublyLinkedNode} \match \emph{SinglyLinkedNode} holds.



%\begin{lstlisting}[label={lst:matchbreak},caption={Matching relation in the break method}]
%pubic void break(SinglyLinkedNode node) {
%	SinglyLinkedNode newNode = new SinglyLinkedNode();
%	node.setNext(newNode);
%}
%\end{lstlisting}



\section{Match-Bounded Quantification}
However, the example in \autoref{lst:break} is still not correct
typeable as long as only is known that the matching relation between
\emph{DoublyLinkedNode} and \emph{SinglyLinkedNode} holds since assigning
objects to variable is not safe if only is known that the variable's type
matches the object type. This is desirable in homogeneous data structures
but not in heterogeneous. So matching and \MyType together is a good match
for such structures but lacks on flexibility for many other situations.

<<<<<<< HEAD
=======
\section{Match-Bounded Quantification}
However, the example in \autoref{lst:break} is still not correct
typeable as long as only is known that the matching relation between
\emph{DoublyLinkedNode} and \emph{SinglyLinkedNode} holds since assigning
objects to variable is not safe if only is known that the variable's type
matches the object type. This is desirable in homogeneous data structures
but not in heterogeneous. So matching and \MyType together is a good match
for such structures but lacks on flexibility for many other situations.

>>>>>>> Doc: Language Principles and Background added
To tackle such unwanted inflexibility matching can be extended
with type parametrisation, called match-bounded quantification
\cite{abadi_subtyping_1996}. 
\section{Matching as F-Bounded Subtyping}
\subsection{Type Operators}


\section{Matching as Higher-Order Subtyping}

\section{Example with Matching}

