
\part{Theoretical Background}
\chapter{Subtyping vs. Subclassing}
In this chapter we want you to get familiar with the terms subtyping
and subclassing and their differences. The concept of subtyping is widely
known through most modern object oriented languages like Java and C++. This
chapter will first describe the drawbacks of this concept and later introduce
the concept of subclassing to provide a solution to these problems. \\

\section{Sharing types versus implementation}
Although the term \emph{class} is used in modern object oriented languages
like Java and C++, the concept behind it is actually the concept of subtypes.
%Although we are familiar with the term class in most modern object oriented
%programming languages like C++ and Java, these are actually types in the sense
%of subtyping theory. 
In these languages, the type hierarchy is directly linked
to the implementation hierarchy, in other words, inheritance automatically 
creates a subtype. Of a theoretical point of view however, inheritance is merely
a mechanism to reuse code in further specialisations of classes. This leads us
to the first conflict: sharing types vs. the implementation. To understand this
have a look at example \ref{fig:implementationConflict} \cite{simons_theory_2003-4}: % reference to simons?

\begin{figure}[H]
\center
\begin{emp}[classdiag](20, 20)

Class.Shape("Shapes")()("+move(x, y):Integer", "+drawOn(c: Canvas)");
Class.Ellipse("Ellipse")("f1, f2: Point", "r, s: Integer")();
Class.Rectangle("Rectangle")("o: Point", "w, h: Integer")();
Class.Circle("Circle")("{f1 = f2, r = s}")();
Class.Square("Square")("{w = h}")();

Ellipse.ne = Shape.s + (-10, -20);
Rectangle.nw = Shape.s + (10, -20);
Circle.n = Ellipse.s + (0, -20);
Square.n = Rectangle.s + (0, -20);

drawObjects(Shape, Ellipse, Rectangle, Circle, Square);
link(inheritance)(Ellipse.n -- Shape.s);
link(inheritance)(Rectangle.n -- Shape.s);
link(inheritance)(Circle.n -- Ellipse.s);
link(inheritance)(Square.n -- Rectangle.s);

Class.Point("Point")("x, y: Integer")();

Point.w = Shape.e + (100, 5);
Class.CircleR("Circle")("r: Integer")();
Class.SquareR("Square")("w: Integer")();
Class.EllipseR("Ellipse")("p, q: Integer", "s: Integer")();
Class.RectangleR("Rectangle")("h: Integer")();

CircleR.ne = Point.s + (-10, -20);
EllipseR.n = CircleR.s + (0, -20);
SquareR.nw = Point.s + (10, -20);
RectangleR.n = SquareR.s + (0, -20);

drawObjects(Point, CircleR, SquareR, EllipseR, RectangleR);
link(inheritance)(CircleR.n -- Point.s);
link(inheritance)(EllipseR.n -- CircleR.s);
link(inheritance)(SquareR.n -- Point.s);
link(inheritance)(RectangleR.n -- SquareR.s);

\end{emp}
\caption{Sharing types vs. implementation}
\label{fig:implementationConflict}
\end{figure}

The left hierarchy expresses the conceptual family: A Circle is a special
kind of an Ellipse, so is Square of a Rectangle, and these are all a Shape.
The hierarchy on the right however shows how one could derive properties and 
add variables or methods to the type. The Circle on the left, however, does
not actually ''extend`` the Ellipse, since it does not add properties, instead
it rather removes the property of having two radii. The right hierarchy in return
is conceptual nonsense, since a Circle is not a kind of Point. Because of that,
we want to use extended concepts of classification and typing, which will be
explained later.

\section{Problem of recursive closure}
Another problem of the subtyping concept we nowadays have in most object 
oriented languages is the problem of contravariance: the arguments of a method
that is derived from a super type and overwrites the method in the super type
can only have a more general or same argument type, but not a more specific one: 

\begin{figure}[H]
\center
\begin{emp}[classdiag](20, 20)

Class.A("A")()("+method(arg: T')");
Class.B("B")()("+method(arg: T)");

B.e = A.w + (-20, 0);
drawObjects(A, B);
link(inheritance)(B.e -- A.w);

\end{emp}
\caption{Contravariance: the argument type in B is more specific than the one in A}
\label{fig:contravariance}
\end{figure}

This restriction makes perfectly sense for the type security in
programming languages. For certain class constellations it leads to
further problems though.

Assuming there is a class \emph{Animal} that has the method \emph{mate} that takes 
an argument of the type \emph{Animal} and returns a type \emph{Animal}. Intuitively,
all other animal types would be derived from this type, like \emph{Dog} or
\emph{Cat} which would have more specific arguments that accept only values of
the type of itself, so that dogs can only mate with dogs and cats only
with cats \cite{simons_theory_2003-1}. Because of the contravariance
restriction in subtyping this cannot be achieved by overriding the
method with a more specific argument type. A similar problem is the
method \emph{Object.equal: Object $\rightarrow$ Boolean} in Java. \\

\section{Shizophrenic self-reference}


% estimated pages: 4
\chapter{Matching}
% estimated pages: 2-3
