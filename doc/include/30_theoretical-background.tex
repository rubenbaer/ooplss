
\part{Theoretical Background}
\chapter{Subtyping vs. Subclassing}
In this chapter we want you to get familiar with the terms subtyping
and subclassing and their differences. Both concepts exist in some of
the widely known object oriented programming languages like Java or C++, but are
usually mixed up.

\section{Sharing types versus implementation}
\label{sec:sharingTypes}

Although the term \emph{class} is used in modern object oriented
languages like Java and C++, the concept behind it is actually the
concept of subtypes.  The word type is in the sense of data type, such
as integer, boolean etc., but could also be extended types like objects
in object oriented languages. They determine the way data is stored and
what operations can be done on them.

In object oriented languages like Java and C++, the type hierarchy
is directly linked to the implementation hierarchy, in other words,
inheritance automatically creates a subtype. Of a theoretical point
of view however, inheritance is merely a mechanism to reuse code in
further specialisations of classes. This leads us to the first conflict:
sharing types vs. the implementation. To understand this have a look at
example \ref{fig:implementationConflict} \cite{simons_theory_2003-4}:
% reference to simons?

\begin{figure}[H]
\center
\begin{emp}[classdiag](20, 20)

Class.Shape("Shapes")()("+move(x, y):Integer", "+drawOn(c: Canvas)");
Class.Ellipse("Ellipse")("f1, f2: Point", "r, s: Integer")();
Class.Rectangle("Rectangle")("o: Point", "w, h: Integer")();
Class.Circle("Circle")("{f1 = f2, r = s}")();
Class.Square("Square")("{w = h}")();

Ellipse.ne = Shape.s + (-10, -20);
Rectangle.nw = Shape.s + (10, -20);
Circle.n = Ellipse.s + (0, -20);
Square.n = Rectangle.s + (0, -20);

drawObjects(Shape, Ellipse, Rectangle, Circle, Square);
link(inheritance)(Ellipse.n -- Shape.s);
link(inheritance)(Rectangle.n -- Shape.s);
link(inheritance)(Circle.n -- Ellipse.s);
link(inheritance)(Square.n -- Rectangle.s);

Class.Point("Point")("x, y: Integer")();

Point.w = Shape.e + (100, 5);
Class.CircleR("Circle")("r: Integer")();
Class.SquareR("Square")("w: Integer")();
Class.EllipseR("Ellipse")("p, q: Integer", "s: Integer")();
Class.RectangleR("Rectangle")("h: Integer")();

CircleR.ne = Point.s + (-10, -20);
EllipseR.n = CircleR.s + (0, -20);
SquareR.nw = Point.s + (10, -20);
RectangleR.n = SquareR.s + (0, -20);

drawObjects(Point, CircleR, SquareR, EllipseR, RectangleR);
link(inheritance)(CircleR.n -- Point.s);
link(inheritance)(EllipseR.n -- CircleR.s);
link(inheritance)(SquareR.n -- Point.s);
link(inheritance)(RectangleR.n -- SquareR.s);

\end{emp}
\caption{Sharing types vs. implementation}
\label{fig:implementationConflict}
\end{figure}

The left hierarchy expresses the conceptual family: A \emph{Circle}
is a special kind of an \emph{Ellipse}, so is \emph{Square} of
a \emph{Rectangle}. These objects do not actually ''extend`` their
parents though, instead, they rather remove properties. For instance, the
\emph{Circle} removes the property of having two radii.  The hierarchy on
the right on the other hand is conceptual nonsense. It shows, however,
how one could want to derive and reuse code, in this case the x and
y coordinates. Because of that, inheritance (and reuse) of code and
subtyping should be treated differently.

\section{Problem of recursive closure}
\label{sec:recursiveClosure}
Another problem of the subtyping concept we nowadays have in most object 
oriented languages is the problem of contravariance: the arguments of a method
that is derived  and overwrites the same method in the super type
can only have a more general or same argument type, but not a more specific one: 

\begin{figure}[H]
\center
\begin{emp}[classdiag](20, 20)

Class.A("A")()("+method(arg: T')");
Class.B("B")()("+method(arg: T)");

B.e = A.w + (-20, 0);
drawObjects(A, B);
link(inheritance)(B.e -- A.w);

\end{emp}
\caption{Contravariance: the argument type in B is more specific than the one in A}
\label{fig:contravariance}
\end{figure}

This restriction makes perfectly sense for the type security in
programming languages. For certain class constellations, it leads to
further problems though.

Assuming there is a class \emph{Animal} that has the method \emph{mate}
that takes an argument of the type \emph{Animal} and returns a type
\emph{Animal}. Intuitively, all other animal types would be derived
from this type, like \emph{Dog} or \emph{Cat} which would have more
specific arguments that accept only values of the type of itself,
so that dogs can only mate with dogs and cats only with cats (figure
\ref{fig:animalContravariance}) \cite{simons_theory_2003-1}. Because of
the contravariance restriction in subtyping this cannot be achieved by
overriding the method with a more specific argument type.

\begin{figure}[H]
\center
\begin{emp}[classdiag](20, 20)

Class.Animal("Animal")()("mate(Animal): Animal");
Class.Dog("Dog")()("mate(Dog): Dog");
Class.Cat("Cat")()("mate(Cat): Cat");

Dog.ne = Animal.s + (-20, -20);
Cat.nw = Animal.s + (20, -20);

drawObjects(Animal, Dog, Cat);
link(inheritance)(Dog.n -- Animal.s);
link(inheritance)(Cat.n -- Animal.s);

\end{emp}
\caption{The arguments are more specific, which is not allowed because of the contravariance rule}
\label{fig:animalContravariance}
\end{figure}

A similar problem arises in the method \emph{Object.equals: Object
$\rightarrow$ Boolean}\footnote{For those not familiar with this
notation: Object.equals: Object $\rightarrow$ Boolean means that
the equals method/function takes an Object and returns a Boolean}
in Java. The class \emph{Object} has an implementation of the equals
method that takes an argument of the type \emph{Object}. All objects
automatically are of the type \emph{Object} in Java.  Because of the
constraint of contravariance, it is not possible to override this method
with a more specific argument type which would be reasonable since it does
not make any sense to compare two objects of different types. Instead,
if the programmer wants to implement a new version of this method, he
has to use instanceof to check whether the given object is of the same
type. A much more elegant solution would be to let the type system of
the programming language do the checking.\\

\section{Schizophrenic self-reference}
\label{sec:schizoReferences}

In objects there has to be some recursion variable that refers to the
object itself, to be able to call methods or use values on self . 
In some languages this is called \emph{self} or \emph{this}, in
this explanation, the term self will be used to refer to this variable. \\

There are two main cases when recursion occurs:
\begin{enumerate}
\item When a method accesses methods or properties of the self object
\item When a method has arguments or return values of the same type as the object
\end{enumerate}

The first case is problematic when objects are derived: it is not quite
clear to which object the self variable should refer after the derivation.
In C++ and Java, the self-reference in inherited methods refers to the
base object that was derived. This means that an object may contain
many versions of self-references, which is called \emph{schizophrenic
self-reference}. Other languages like Smalltalk and Eiffel treat the
self-reference differently: they redirect the self-reference to the
derived object. \\

An example of shizophrenic self-reference could be a two dimensional
vector type \emph{Vec2D} which has two coordinates and the methods
\emph{identity} and \emph{equals}. The identity method returns the
reference to the object itself and the equals method compares two
objects of this type. It therefore takes an argument of the type
\emph{Vec2D}. Assuming there is a subtype \emph{Vec3D} that inherits
all these methods, adds a z coordinate and overrides the equals
method. Let us further assume that the rule of contravariance does not
apply here. Clearly the equals method of \emph{Vec3D} takes an argument
of the type \emph{vec3D}. Listing \ref{fig:schizoListing} shows this
constellation (in pseudo-code):

\begin{figure}[H]
\begin{lstlisting}
class Vec2D {
	int x,y;

	Vec2D identity() {
		return self;
	}

	bool equals(Vec2D vec) {
		return vec.x == self.x && vec.y == self.y;
	}
}

class Vec3D extends Vec2D {
	int z;

	bool equals(Vec2D vec) {
		return vec.x == self.x && vec.y == self.y && vec.z == self.z;
	}
}
\end{lstlisting}
\caption{An example of schizophrenic self-reference}
\label{fig:schizoListing}
\end{figure}

In the derived class \emph{Vec3D} the self reference in the equals 
method refers to a \emph{Vec3D} object while the one in identity
refers to a \emph{Vec2D} object. This is why an instance of the class
\emph{Vec3D} would be schizophrenic.

This is how the fixation of self-references is done in the subtyping
concept: before the combination (i.e. inheritance) of the objects. In the
concept of subclassing however, it is done after the combination.

\section{Subclassing}

The goal of the concept of subclassing is now to provide a somewhat
different kind of inheritance. With this inheritance, the programmer should
be able to inherit code without automatically creating a subtype. 
\marginpar{Mention here that our programming language will support both?}
This solves the problem described in section \ref{sec:sharingTypes}. Since
subclassing does not create subtypes, the restriction of contravariance, 
described in section \ref{sec:recursiveClosure}, is of no relevancy
anymore. And as already mentioned, the fixation of the self
references and types is done after the inheritance, so there will be no
schizophrenic self-references as described in case 1 in 
\ref{sec:schizoReferences}. \\

In subclassing however, the question rises: how should return values
and arguments be typed (see case 2 in \ref{sec:schizoReferences}) when
defining the methods and fields, since the programmer is not able to know
of what type the subclass will be. This is why there has to be some sort
of placeholder for such cases: the \emph{MyType}. The MyType placeholder
is then substituted with the current type after the inheritance.


\chapter{Matching}
% estimated pages: 2-3
Subtyping is one of the most fundamental property in object-oriented languages
in todays ....

\section{Matching as F-Bounded Subtyping}

\section{Matching as Higher-Order Subtyping}


