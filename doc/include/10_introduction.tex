\chapter{Introduction}
Object-oriented programming languages enjoy a wide popularity in today's
developer community. Consequently different languages are introduced with
all specialities to support the programmer in its daily work. That's may
the reason why many different approaches were taken to create useful, safe
and comprehensive languages. However, the most modern and widely spread
object-oriented languages provide subtyping polymorphism which is a well
known relation and often used feature within these languages. This makes
code reuse fast and easy but there are some short comes in languages
that does only provide subtyping as type relation. Since subtyping
is restrictive it inhibits proper inheritance of binary methods like
\emph{equals}. To over come this restriction languages like Java and \cs
introduced type parametrisation which is better known as \emph{generics}
or in \cpp as \emph{templates}. But this still does not solve the problem
of binary methods by extension. Other relations and class combinations
are considered as well as useful in object-oriented languages. One of them
is the \emph{matching} relation and the concept of subclassing.

This thesis project aims to design and develop a prototypical language
that integrates both models, that of safe subtyping as well as safe
subclassing. In this language, the programmer decides which one is used
and fits in the problem's scope.

This paper only regards statically typed object-oriented languages and does
not deal with dynamic languages at all. The authors assume that large
software benefits from statically typed languages more than from dynamic
ones.

\section{Purpose and Situation}
\subsection{Motivation}
Many programmer consider inheritance as a key feature in object-oriented
languages and as an important characteristic for proper code reuse and
software design. Often inheritance is put on the same level as subtyping
and is not distinguished. However, many researched does not agree with
this notion instead they distinguish between two models: subtyping and
inheritance respectively subclassing \cite{taivalsaari_notion_1996}.
Both models are independent but not exclusive. Different approaches were
taken to combine both models by using special type variables like \mytype
and type constraints as \emph{exact} types. However, this project aims to
try an other solution by combining both models where the programmer has
to full power about what to choose by introducing two kinds of derivations
One is called \emph{subclassing} and the other \emph{subtyping}. Depending
on the derivation method the \mytype variable will get bound at different
times. To test this thesis a prototypical language was defined and some
of this features were implemented.

\subsection{Objectives and Limitations}
Generally speaking the project consists of two parts. First a languages
that contains subclassing and subtyping will be formally defined. The
second part is to implement the language as far as possible which contains
a lexer and parser as well as an own type checker. After wards the
intermediate representation of the program is translated to the high-level
language Java.

For this project, the special focus lies on the type systems and the language
design. It is not intended to provide a full programming languages that is
ready for daily use. It is more two show that the model works and that some
problems raising at design solutions and implementing them can be solved
with this model.

\subsection{Preliminary Activities}
The subject of the project is generally new two both authors. Within
the study course does no major exists on this topic. To gain the prior
knowledge about this subject some introductory courses were taken;
\emph{Functional Programming} and \emph{Automata and Formal Languages}.
One of authors had also taken \emph{Computability and Complexity} as
formal course. He also has written a project paper about type systems
with regards on theoretical backgrounds and practice use and impacts. All
of these works are only generally related with the topics considered in
this thesis project. Consequently this project contains many topics that
were new to the authors.

\subsection{New Learning Contents}
Next to the formal learning contents for this module, there are many
new subjects for the authors. The main new parts are listed below:

\squishlist
	\item Design of a programming language from scratch
	\item Designing a compiler from lexer to translated output
	\item Implementing a compiler with all is aspects
	\squishlist
		\item Lexing and parsing
		\item Aggregating an abstract syntax tree
		\item Type checker
		\item Translation of intermediate language to concrete output
	\squishend
	\item The parser generator \emph{ANTLR3}
\squishend

\section{Related Work}
Since two different models of class combination are integrated in this
work, different other related work were considered for this project.
Without other works done in the last two decades this project would not
be possible.

The idea for this is based on the ideas from Bruce and Abadi and Cardelli.
They showed where the problems in binary methods are and how they
can get tackled and that the notion of subtyping is not sufficient for
different situations\cite{bruce_binary_1995,abadi_subtyping_1996}. These
ideas are based on the work of Canning which presented the notion
of function-bounded polymorphism in object-oriented languages
\cite{canning_f-bounded_1989}.

To adopt a better interpretation of function-bounds
with subtyping the notion on inheritance and
higher-order subtyping was refined by the following work
\cite{steffen_higher-order_1994,cook_inheritance_1990,taivalsaari_notion_1996}.
These works were used to understand the correct idea of the models used
in subtyping and subclassing.

A comprehensible presentation of the notion of classification with
both models of subtyping and subclassing was presented by Simons in
\cite{simons_theory_2002-2} which was his PhD topic. It was a series of
articles within the Journal of Object Technologies.

Within the last fifteen years a lot of other prototypical research
languages were developed to investigate more expressive languages. A
language that contains both, subtyping and matching was presented
by Gawecki and Matthes \cite{gawecki_tool:_1995}. An other language
that goes in a similar direction is PolyToil which is a extension
of Toil with polymorphism invented by Bruce, Schuett and van Gent
\cite{bruce_polytoil:_1995}. The simpler version of PolyToil was
published shortly afterwards which is named $\mathcal{LOOM}$ to show
that subtyping is not as good as thought for object-oriented languages
\cite{bruce_subtyping_1997}. This language is the basis of the Java
extension LOOJ which integrates the ideas of matching and exact types
within Java.

An other aspect of subclassing and subtyping has the focus
on flexible software composition without subtyping. One
of the first approaches were mixins for a Lisp dialect
\cite{bracha_mixin-based_1990}. Introducing this new kind if code reuse
were later refined under the name traits which are behavioural software
units \cite{schaerli_traits:_2003,ducasse_traits:_2006} which are easier
then pure mixins since they implement only behavioural extensions and
not a dedicated state.

\section{Outline of the Document}
This document is divided into seven chapters. The first is this introduction. The second
\emph{\nameref{ctr:projectManagement}} introduced the plan how and
when what will be done and what methodologies where chosen to reach
the aim. Here the aim are to outputs: this documentation and
the implementation. This chapter is followed by a chapter the
\emph{\nameref{ctr:theoreticalBackground}}. There the fundamental
backgrounds were taken into account. It is used to introduce the
reader with the topic and vocabulary. There are also three examples
where current languages like Java and \cs reach their expressiveness
and force the user of it to bypass the safety of the type system
by using unsafe constructs like \emph{casts}. The following
chapter \emph{\nameref{ctr:languageSpecification}} contains
the main specification of the language \ooplss. After the first
definitions the language is introduced in a incremental way where
the semantics of the used constructs are presented. Then the chapter
\emph{\nameref{ctr:swDesignImplementation}} shows how the software is
structures and how the compiler is designed. This is followed by the
chapter \emph{\nameref{sec:comparisonScala}} makes a comparison between
\ooplss and some structures of Scala\nomenclature{Scala}{Abbreviates
\emph{A Scalable Language} and is an advanced multi-paradigm
programming language designed at the EPFL}. The first case is how the
\emph{self}-variable is explicitly respectively implicitly typed and
the seconds takes regard on how software can be composed with traits
respectively with subclasses. The last chapter is
\emph{\nameref{ctr:discussionConclusion}} and discusses the examples
introduced in chapter \emph{\nameref{ctr:theoreticalBackground}} and how
they can be expressed with \ooplss. Some further work for the language
is proposed as well.

After the regular content the appendix contains a manual, the type
inference rules, some example codes, the journal and the original
definition of the project.

