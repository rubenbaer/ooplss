\part{Project Management and Technologies}
\chapter{Methodologies}
Many different software development processes have risen since the
breakthrough of software developing. Two major trends can be recognised;
Sequential and iterative design processes. Although iterative processes
have many advantages compared to the others, it is difficult to follow
strictly this design method. On one hand the development time is very
short for regular iterations on the other hand the project includes
many non standard design and development parts where such a process is
difficult to perform. E.g. extending subsequently the grammar may end
in major changes in a language. However, a not very strict iterative
model is chosen.

\section{Iterative and Agile Development}
This project was build iteratively in the sense of continuous
refinement in the definition of the language. The language definition and
implementation goes hand in hand and gives direct feedback. This makes it
possible to test the definition on a concrete implementation. Further
parts from extreme programming are used. Manly the concept of pair
programming for critical parts which provide interfaces between the
compiler stages.

\section{Test-Driven Development}
A major goal is to provide a good and robust code basis. To ensure that
this claim holds, test-driven development is performed. With the use of
unit tests code breaking changes can be easily detected.

\section{Regular Meetings}
The Bern University of Applied Science does not provide a major in
topics used in this thesis. To ensure success regular meetings with the
supervisors are hold. With this early divergence and loss of target should
be prevented. A meeting between the students team and the supervisor
should be at least every two weeks.

\chapter{Project Schedule}
\section{Tasks}
\paragraph{Kick-Off}
In this first phase the tasks will be identified and shortly described. Since the prior knowledge of type systems and programming languages uniform some knowledge exchange is to do. Important papers will get reviewed and discussed.

\paragraph{Documentation Part I / II}
Part I shows the used project management methodology. It has to be evaluated how an iterative model can be adopted to be usable in this subject. Part II shows the current problems within object-oriented languages with subtyping and no subclassing. Further the project idea will get stated and which benefits the language will have. Next to the normal writing work the used tools has to be evaluated

\paragraph{Grammar / Lexer}
Here an abstract syntax is defined. With the chosen parser generator the lexer part will be defined and be ready for the parser.

\paragraph{Types}
Parallel to the parser the supported type constructs has to be defined. Detailed type rules are not yet necessary but needed for the translation definition from the source language to the target language.

\paragraph{Parser}
Based on the used lexer a parser that builds an abstract syntax tree needs to be written. Without this tree no further work is possible.

\paragraph{Tree Walker}
For the subsequent tasks a tree walker is inevitable. Without this whether a symbol table nor a type checker can be build.

\paragraph{Code Translation Definition}
Since the target language does not natively support all the type constructs used in \ooplss are available a strategy needs to be found how the source code can be translated to the target language which will compile there.

\paragraph{Symbol Table Construction}
The symbol table contains the necessary type context information for type checking the environment under investigation.

\paragraph{Type Checker}
This phase contains two tasks. First the type rules has to be identified and written down. Consequently the rules has to be implemented and tested.

\paragraph{Code Translation}
After some type checking the code can be translated to the target language.

\paragraph{Documentation}
All over the project work the documentation will be extended and reflect the work done.

\section{Diagram}
\begin{sideways}
	\centering
	\input{include/21_gantt}
\end{sideways}

\chapter{Technologies}

\section{Tools and Software}
\begin{description}
	\item[ANTLR3] ANTLR\footnote{ANother Tool for Language Recognition} is an advanced LL(*) parser generator with support for AST\footnote{Abstract Syntax Tree} generation and tree walking respectively rewriting.
	\item[ANTLRWork] Workbench for ANTLR grammers with debug environment.
	\item[ANTLR IDE] Eclipse plugin for editing ANTLR grammars.
	\item[Apache Ant] Java tool for automated builds.
	\item[Eclipse] Open source integrated development environment for Java. Used for writing non-ANTLR parts.
	\item[Git] Distriputed source control system. Used for the development and as a replacement for Subversion. The project is hosted by \href{https://www.github.com/rubenbaer/ooplss}{GitHub}
	\item[GUnit] Unit testing framework for ANTLR grammars.
	\item[Java] Target language of \ooplss and development language of the compiler.
	\item[JUnit] Unit testing framework for Java source code.
	\item[\LaTeX] A macro collection for the \TeX system. Used for the documentation. Every thing is written with \LaTeX
	\item[Subversion] Source control system with linear history. Used in the first weeks.
\end{description}

\section{Standards and Guidelines}
Coding guidelines

