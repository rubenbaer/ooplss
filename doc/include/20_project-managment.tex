\chapter{Project Management and Technologies}
\label{ctr:projectManagement}
\section{Methodologies}
Many different software development processes have risen since the
breakthrough of software developing. Two major trends can be recognised:
sequential and iterative design processes. Although iterative processes
have many advantages compared to the sequential ones, it was difficult to follow
this design method strictly in the context of this project. On one hand is the
development duration, which is very short for regular iterations, on the
other hand the fact that the project includes many non standard design and development
parts where such a process is difficult to perform. Subsequently extending the 
grammar may for example lead to major changes in a language. However,
a not very strict iterative model was chosen.

\subsection{Implementation Project}
The project aims at showing how subclassing and subtyping can be brought
together uniformly. With this intension, a language specification is provided which
was implemented in a prototypical way. Using this implementation and
specification \ooplss and Scala will be compared to
show which advantages and which drawbacks come about with the ideas implemented
in this thesis project.

\subsection{Iterative and Agile Development}
This project was built iteratively in terms of continuous refinement
of the language definition. The language definition and implementation
went hand in hand and gave direct feedback to each other. This enabled us
to test the definition on a concrete implementation. Further parts from
extreme programming have been used, mainly the concept of pair programming
for critical parts which provide interfaces between the compiler
stages.
The approach was to implement a core language and then to refine it step
by step.

However, due the fact that the project team members are not full time
students and have to work besides the studying, it was very difficult
to plan reasonable iterations.

\subsection{Test-Driven Development}
A major goal was to provide a good and robust code basis. To uphold this
goal, test-driven development was performed. With the use of
unit tests, code breaking changes could easily be detected. This is inevitable
since many parts are highly fragile, e.g., small changes in the grammar can
cause many changes in the code since the grammar will recognise a complete
different language.

\subsection{Regular Meetings}
As mentioned before, the Berne University of Applied Science does not provide a major in
topics used in this thesis. To ensure success, regular meetings with the
supervisor have been hold. By doing this, early divergence and loss of target could
be prevented. A meeting between the student team and the supervisor
was held at least every second week.

\section{Project Schedule}
\subsection{Tasks}
\paragraph{Kick-Off}
In this first phase the tasks were identified and shortly
described. Since prior formal knowledge of type systems and programming
languages is needed to comprehend the task of this project, some
knowledge exchange had to be undertaken. Important papers were reviewed
and discussed.

\paragraph{Documentation Chapters 2 and 3}
Chapter 2 shows the project management methodology that was used. It had to be
evaluated how an iterative model can be adopted to be usable in this
subject. Chapter 3 shows the problems within today's object-oriented
languages with subtyping and no subclassing. Furthermore, the project idea
was stated along with the benefits that the language will have. Next
to the normal writing work the used tools have been evaluated.

\paragraph{Grammar and Lexer}
An abstract syntax was defined. With the chosen parser generator
the lexer part was be defined for the parser work.

\paragraph{Types}
Parallel to the parser the supported type constructs had to be
defined. Detailed type rules were not yet necessary but needed for the
translation definition from the source language to the target language.

\paragraph{Parser}
Based on the lexer a parser that builds an abstract syntax tree
(AST) needed to be written. Without this tree no further work was possible.

\paragraph{Tree Walker}
For the subsequent tasks a tree walker is inevitable. Without this
neither a symbol table nor a type checker can be built.

\paragraph{Code Translation Definition}
Since the target language does not natively support all the type
constructs used in \ooplss, a strategy was needed to be found
how the source code can be translated to the target language to make it
compile there.

\paragraph{Symbol Table Construction}
The symbol table contains the necessary type context information for
type checking the environment under investigation.

\paragraph{Type Checker}
This phase contained two tasks. First the type rules had to be identified
and written down. Consequently, the rules had to be implemented and tested.

\paragraph{Code Translation}
After some type checking the code was translated to the target language.

\paragraph{Documentation}
All over the project work the documentation was extended to reflect the work done.

\subsection{Project Flow Diagram}
\begin{figure}[H]
	\centerline{
		\begin{sideways}
			\input{include/21_gantt}
		\end{sideways}
	}
	\caption{Project flow diagram}
	\label{fig:gantt}
\end{figure}

The Gantt chart in \Cref{fig:gantt} shows the different major parts performed
during the project. This can \emph{not} be understood as a classical Gantt for
sequential design process. It is not intended to show where exactly tasks have
started and finished. However, it shows at which time of the project we had
which major implementation focus. For example, it is essential to see that
the parser was refined still during the implementation of the type
checker. This gave the opportunity to sequentially add new features to the
language.

\section{Technologies}

\subsection{Tools and Software}
\begin{description}
	\item[ANTLR3] ANTLR\footnote{ANother Tool for Language
	Recognition} is an advanced LL(*) parser generator with support
	for AST\footnote{Abstract Syntax Tree} generation and tree
	walking or rewriting.
	\item[ANTLRWork] Workbench for ANTLR grammars with debug
	environment.
	\item[ANTLR IDE] Eclipse plugin for editing ANTLR grammars.
	\item[Apache Ant] Java tool for automated builds.
	\item[Eclipse] Open source integrated development environment
	for Java. Used for writing the non-ANTLR parts.
	\item[Git] Distributed source control system. Used for the
	development and as a replacement for Subversion. The project is
	hosted by \href{https://www.github.com/rubenbaer/ooplss}{GitHub}\footnote{\href{https://www.github.com/rubenbaer/ooplss}{https://www.github.com/rubenbaer/ooplss}}
	\item[GitHub] Free git hosting platform with webinterface. Is
	used for some project management issues. Provides the possibility
	for issue tracking and code reviews.
	\item[GUnit] Unit testing framework for ANTLR grammars.
	\item[Java] Target language of \ooplss and development language
	of the compiler.
	\item[JUnit] Unit testing framework for Java source code.
	\item[\LaTeX] A macro collection for the \TeX system. Used for
	the documentation. The documentation is written with \LaTeX.
	\item[Subversion] Source control system with linear history. Used
	in the first weeks.
	\item[groff]
	\item[Make]
	\item[Doxygen]
	\item[common-cli]
	\item[zotero]
\end{description}
\todo{Describe and order these items}

\subsection{Standards and Guidelines}
The source code of the \ooplss compiler, which is written
in Java, follows the official guidelines from
Oracle.\footnote{\href{http://www.oracle.com/technetwork/java/codeconv-138413.html}{http://www.oracle.com/technetwork/java/codeconv-138413.html}}

An appropriate project structure was chosen, which is explained in the
project root's README.md, or in Listing \ref{lst:README}.

\begin{listing}
	\VerbatimInput[frame=single,numbers=left,firstline=19,lastline=40]{../README.md}
	\caption{Excerpt from README.md}
	\label{lst:README}
\end{listing}
