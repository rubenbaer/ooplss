\chapter{Project Management and Technologies}
\section{Methodologies}
Many different software development processes have risen since the
breakthrough of software developing. Two major trends can be recognised;
Sequential and iterative design processes. Although iterative processes
have many advantages compared to the others, it is difficult to follow
strictly this design method in this context for this project. On one
hand the development time is very short for regular iterations on the
other hand the project includes many non standard design and development
parts where such a process is difficult to perform. For example, extending
subsequently the grammar may end in major changes in a language. However,
a not very strict iterative model is chosen.

\subsection{Implementation Project}
The project aims to show how subclassing and subtyping can be brought
together uniformly. For this a language specification is provided which
is implemented in a prototypical way. Using this implementation and
specification a comparison between \ooplss and Scala will be done to
show where some advantages or drawbacks come with the ideas implemented
in this project thesis.

\subsection{Iterative and Agile Development}
This project was build iteratively in the sense of continuous
refinement in the definition of the language. The language definition and
implementation goes hand in hand and gives direct feedback. This makes it
possible to test the definition on a concrete implementation. Further
parts from extreme programming are used. Mainly the concept of pair
programming for critical parts which provide interfaces between the
compiler stages. Further is a small not every feature proposed implemented.
First of all a core language needs to be fully enrolled which will be refined
step by step.

However, the fact that the project team are not full time students and have
to work beside the study and project work, it is very difficult to plan
reasonable iterations.

\subsection{Test-Driven Development}
A major goal is to provide a good and robust code basis. To ensure that
this claim holds, test-driven development is performed. With the use of
unit tests code breaking changes can be easily detected. This is inevitable
since many parts are highly fragile, e.g., small changes in the grammar can
cause many changes in the code since the grammar will recognise a complete
other language.

\subsection{Regular Meetings}
The Bern University of Applied Science does not provide a major in
topics used in this thesis. To ensure success regular meetings with the
supervisors are hold. With this early divergence and loss of target should
be prevented. A meeting between the students team and the supervisor
should be at least every two weeks.

\section{Project Schedule}
\subsection{Tasks}
\paragraph{Kick-Off}
In this first phase the tasks will be identified and shortly
described. Since the prior knowledge of type systems and programming
languages is needed to understand the task of this project, some
knowledge exchange has to be done. Important papers will get reviewed
and discussed.

\paragraph{Documentation Chapters 2 and 3}
Chapter 2 shows the used project management methodology. It has to be
evaluated how an iterative model can be adopted to be usable in this
subject. Chapter 3 shows the current problems within object-oriented
languages with subtyping and no subclassing. Further the project idea
will get stated along with the benefits that the language will have. Next
to the normal writing work the used tools has to be evaluated

\paragraph{Grammar and Lexer}
Here an abstract syntax is defined. With the chosen parser generator
the lexer part will be defined for the parser work.

\paragraph{Types}
Parallel to the parser the supported type constructs have to be
defined. Detailed type rules are not yet necessary but needed for the
translation definition from the source language to the target language.

\paragraph{Parser}
Based on the used lexer a parser that builds an abstract syntax tree
(AST) needs to be written. Without this tree no further work is possible.

\paragraph{Tree Walker}
For the subsequent tasks a tree walker is inevitable. Without this
neither a symbol table nor a type checker can be built.

\paragraph{Code Translation Definition}
Since the target language does not natively support all the type
constructs used in \ooplss, a strategy needs to be found
how the source code can be translated to the target language to make it
compile there.

\paragraph{Symbol Table Construction}
The symbol table contains the necessary type context information for
type checking the environment under investigation.

\paragraph{Type Checker}
This phase contains two tasks. First the type rules have to be identified
and written down. Consequently, the rules have to be implemented and tested.

\paragraph{Code Translation}
After some type checking the code can be translated to the target language.

\paragraph{Documentation}
All over the project work the documentation will be extended and reflect the work done.

\subsection{Diagram}
\begin{figure}[H]
	\centerline{
		\begin{sideways}
			\input{include/21_gantt}
		\end{sideways}
	}
	\caption{Project flow}
	\label{fig:gantt}
\end{figure}

The Gantt chart in \Cref{fig:gantt} shows the different major parts performed
during the project. This can \emph{not} be understand as a classical Gantt for
sequential design process. It is not intended to show where exactly tasks are
beginning and finishing. However, it shows at which time of the project we had
the major focus of implementation. For example, it is essential to see that some
work will on the parser will be done even during the implementation of the type
checker. This rises the opportunity to add sequential new features to the
language.

\section{Technologies}

\subsection{Tools and Software}
\begin{description}
	\item[ANTLR3] ANTLR\footnote{ANother Tool for Language
	Recognition} is an advanced LL(*) parser generator with support
	for AST\footnote{Abstract Syntax Tree} generation and tree
	walking respectively rewriting.
	\item[ANTLRWork] Workbench for ANTLR grammars with debug
	environment.
	\item[ANTLR IDE] Eclipse plugin for editing ANTLR grammars.
	\item[Apache Ant] Java tool for automated builds.
	\item[Eclipse] Open source integrated development environment
	for Java. Used for writing the non-ANTLR parts.
	\item[Git] Distributed source control system. Used for the
	development and as a replacement for Subversion. The project is
	hosted by \href{https://www.github.com/rubenbaer/ooplss}{GitHub}\footnote{\href{https://www.github.com/rubenbaer/ooplss}{https://www.github.com/rubenbaer/ooplss}}
	\item[GitHub] Free git hosting platform with webinterface. Is
	used for some project management issues. Provides the possibility
	for issue tracking and code reviews.
	\item[GUnit] Unit testing framework for ANTLR grammars.
	\item[Java] Target language of \ooplss and development language
	of the compiler.
	\item[JUnit] Unit testing framework for Java source code.
	\item[\LaTeX] A macro collection for the \TeX system. Used for
	the documentation. Everything is written with \LaTeX.
	\item[Subversion] Source control system with linear history. Used
	in the first weeks.
\end{description}

\subsection{Standards and Guidelines}
The source code of \ooplss, which is written in Java, follows the official
guidelines from Oracle.\footnote{\href{http://www.oracle.com/technetwork/java/codeconv-138413.html}{http://www.oracle.com/technetwork/java/codeconv-138413.html}}

For the project structure an appropriate structure for us was chosen.
A detailed explanation is found in the project root's README
respectively in Listing \ref{lst:README}.

\begin{listing}
	\VerbatimInput[frame=single,numbers=left,firstline=19,lastline=40]{../README.md}
	\caption{Excerpt from README.md}
	\label{lst:README}
\end{listing}
